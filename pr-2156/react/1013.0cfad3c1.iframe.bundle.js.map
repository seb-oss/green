{"version":3,"file":"1013.0cfad3c1.iframe.bundle.js","mappings":";AAiCA;AAAA;;;AAEA;ACgGA;AAAA;;AACA;AADA;;;;;;AAKA;AALA;;;;;;AAKA;AALA;;AACA;AADA;;;AAEA","sources":["webpack://green/./dist/libs/core/src/components/segmented-control/segment/segment.component.js","webpack://green/./dist/libs/core/src/components/segmented-control/segmented-control.component.js"],"sourcesContent":["import {\n  __decorateClass\n} from \"../../../chunks/chunk.QU3DSPNU.js\";\nimport { unsafeCSS } from \"lit\";\nimport { property } from \"lit/decorators.js\";\nimport { GdsElement } from \"../../../gds-element.js\";\nimport { gdsCustomElement, html } from \"../../../scoping.js\";\nimport { tokens } from \"../../../tokens.style.js\";\nimport { TransitionalStyles } from \"../../../transitional-styles.js\";\nimport { withSizeXProps } from \"../../../utils/mixins/declarative-layout-mixins.js\";\nimport style from \"./segment.style.css.js\";\nlet GdsSegment = class extends withSizeXProps(GdsElement) {\n  constructor() {\n    super(...arguments);\n    this.selected = false;\n    this.disabled = false;\n    // This is deliberatly not marked as private, since we're setting it from the parent component,\n    // but it is not meant to be set by the consumer.\n    this._isVisible = true;\n  }\n  /**\n   * Whether the segment is currently visible.\n   */\n  get isVisible() {\n    return this._isVisible;\n  }\n  connectedCallback() {\n    super.connectedCallback();\n    TransitionalStyles.instance.apply(this, \"gds-segmented\");\n    this.setAttribute(\"role\", \"listitem\");\n  }\n  render() {\n    return html`<button\n      aria-current=${String(this.selected)}\n      ?disabled=\"${this.disabled}\"\n    >\n      <slot></slot>\n    </button>`;\n  }\n};\nGdsSegment.styles = [...tokens, unsafeCSS(style)];\n__decorateClass([\n  property({ type: Boolean, reflect: true })\n], GdsSegment.prototype, \"selected\", 2);\n__decorateClass([\n  property()\n], GdsSegment.prototype, \"value\", 2);\n__decorateClass([\n  property({ type: Boolean, reflect: true })\n], GdsSegment.prototype, \"disabled\", 2);\nGdsSegment = __decorateClass([\n  gdsCustomElement(\"gds-segment\")\n], GdsSegment);\nexport {\n  GdsSegment\n};\n","import {\n  __decorateClass,\n  __privateAdd,\n  __privateGet,\n  __privateMethod,\n  __privateSet\n} from \"../../chunks/chunk.QU3DSPNU.js\";\nvar _value, _GdsSegmentedControl_instances, handleSlotChange_fn, _scrollLeft, _scrollRight, _updateScrollBtnState, _updateScrollBtnStateDebounced, _updateIndicator, _handleSegmentClick, _updateSelectedFromValue;\nimport { localized, msg } from \"@lit/localize\";\nimport { unsafeCSS } from \"lit\";\nimport { property, query, state } from \"lit/decorators.js\";\nimport { GdsElement } from \"../../gds-element.js\";\nimport { gdsCustomElement, html } from \"../../scoping.js\";\nimport { tokens } from \"../../tokens.style.js\";\nimport { TransitionalStyles } from \"../../transitional-styles.js\";\nimport { resizeObserver } from \"../../utils/decorators/resize-observer.js\";\nimport { watch } from \"../../utils/decorators/watch.js\";\nimport {\n  withLayoutChildProps,\n  withMarginProps,\n  withSizeXProps\n} from \"../../utils/mixins/declarative-layout-mixins.js\";\nimport { IconChevronLeft } from \"../icon/icons/chevron-left.component.js\";\nimport { IconChevronRight } from \"../icon/icons/chevron-right.component.js\";\nimport { GdsSegment } from \"./segment/segment.component.js\";\nimport style from \"./segmented-control.style.css.js\";\nconst debounce = (fn, delay) => {\n  let timeoutId;\n  return () => {\n    clearTimeout(timeoutId);\n    timeoutId = setTimeout(fn, delay);\n  };\n};\nlet GdsSegmentedControl = class extends withLayoutChildProps(\n  withSizeXProps(withMarginProps(GdsElement))\n) {\n  constructor() {\n    super(...arguments);\n    __privateAdd(this, _GdsSegmentedControl_instances);\n    this.size = \"medium\";\n    __privateAdd(this, _value);\n    this._showPrevButton = false;\n    this._showNextButton = false;\n    this.intersectionObserver = null;\n    __privateAdd(this, _scrollLeft, () => {\n      const nextLeftOutOfView = this.segments.filter(\n        (s, i, arr) => arr[i + 1]?.isVisible && !s.isVisible\n      )[0];\n      if (!nextLeftOutOfView) return;\n      this._elTrack.scrollLeft -= nextLeftOutOfView.offsetWidth;\n    });\n    __privateAdd(this, _scrollRight, () => {\n      const nextRightOutOfView = this.segments.filter((s, i, arr) => arr[i - 1]?.isVisible && !s.isVisible).reverse()[0];\n      if (!nextRightOutOfView) return;\n      this._elTrack.scrollLeft += nextRightOutOfView.offsetWidth;\n    });\n    // Updates the visibility of the scroll buttons\n    __privateAdd(this, _updateScrollBtnState, () => {\n      if (this.segments.every((s) => !s.isVisible)) return;\n      this._showPrevButton = !this.segments[0].isVisible;\n      this._showNextButton = !this.segments[this.segments.length - 1].isVisible;\n    });\n    __privateAdd(this, _updateScrollBtnStateDebounced, debounce(__privateGet(this, _updateScrollBtnState), 50));\n    // Updates the selection indicator position\n    __privateAdd(this, _updateIndicator, () => {\n      const segment = this.segments.find((s) => s.selected);\n      if (segment) {\n        const segmentWidth = segment.offsetWidth;\n        const segmentLeft = segment.offsetLeft;\n        this._elIndicator.style.transform = `translateX(${segmentLeft}px)`;\n        this._elIndicator.style.width = `${segmentWidth}px`;\n      } else {\n        this._elIndicator.style.transform = `translateX(-100%)`;\n        this._elIndicator.style.width = `0px`;\n      }\n    });\n    __privateAdd(this, _handleSegmentClick, (event) => {\n      const selectedSegment = this.segments.find(\n        (s) => s === event.target || s.contains(event.target)\n      );\n      if (selectedSegment) {\n        this.segments.forEach((s) => s.selected = false);\n        selectedSegment.selected = true;\n        __privateSet(this, _value, selectedSegment.value);\n        __privateGet(this, _updateIndicator).call(this);\n        this.dispatchEvent(\n          new CustomEvent(\"change\", {\n            detail: { segment: selectedSegment },\n            bubbles: true,\n            composed: true\n          })\n        );\n      }\n    });\n    __privateAdd(this, _updateSelectedFromValue, () => {\n      if (!__privateGet(this, _value)) return;\n      this.updateComplete.then(() => {\n        const selectedSegment = this.segments.find((s) => s.value === __privateGet(this, _value));\n        if (selectedSegment) {\n          this.segments.forEach((s) => s.selected = false);\n          selectedSegment.selected = true;\n          this._elTrack.scrollLeft = selectedSegment.offsetLeft;\n        }\n      });\n    });\n  }\n  get value() {\n    return __privateGet(this, _value);\n  }\n  set value(val) {\n    __privateSet(this, _value, val);\n    __privateGet(this, _updateSelectedFromValue).call(this);\n  }\n  /**\n   * Returns the segments in the control\n   * @readonly\n   */\n  get segments() {\n    return this._elSlot ? this._elSlot.assignedElements() : [];\n  }\n  connectedCallback() {\n    super.connectedCallback();\n    TransitionalStyles.instance.apply(this, \"gds-segmented-control\");\n    this.updateComplete.then(() => {\n      this._elTrack.addEventListener(\"scroll\", () => {\n        __privateGet(this, _updateScrollBtnStateDebounced).call(this);\n      });\n    });\n  }\n  render() {\n    return html`<button\n        aria-hidden=${!this._showPrevButton}\n        ?inert=${!this._showPrevButton}\n        id=\"btn-prev\"\n        @click=${__privateGet(this, _scrollLeft)}\n        aria-label=${msg(\"Scroll right\")}\n      >\n        <gds-icon-chevron-left />\n      </button>\n      <div id=\"track\" role=\"list\">\n        <slot\n          @click=${__privateGet(this, _handleSegmentClick)}\n          @slotchange=${__privateMethod(this, _GdsSegmentedControl_instances, handleSlotChange_fn)}\n          role=\"none\"\n        ></slot>\n        <div id=\"indicator\" role=\"none\"></div>\n      </div>\n      <button\n        aria-hidden=${!this._showNextButton}\n        ?inert=${!this._showNextButton}\n        id=\"btn-next\"\n        @click=${__privateGet(this, _scrollRight)}\n        aria-label=${msg(\"Scroll right\")}\n      >\n        <gds-icon-chevron-right />\n      </button>`;\n  }\n  _recalculateMinWidth() {\n    this.updateComplete.then(() => {\n      __privateGet(this, _updateScrollBtnStateDebounced).call(this);\n      __privateGet(this, _updateIndicator).call(this);\n    });\n  }\n};\n_value = new WeakMap();\n_GdsSegmentedControl_instances = new WeakSet();\nhandleSlotChange_fn = function() {\n  const selSegmentValue = this.segments.find((s) => s.selected)?.value;\n  if (selSegmentValue) {\n    __privateSet(this, _value, selSegmentValue);\n  }\n  this.intersectionObserver?.disconnect();\n  this.intersectionObserver = new IntersectionObserver(\n    (entries) => {\n      entries.forEach((entry) => {\n        const segment = entry.target;\n        segment._isVisible = entry.intersectionRatio > 0.99;\n        __privateGet(this, _updateScrollBtnStateDebounced).call(this);\n      });\n    },\n    {\n      root: this._elTrack,\n      threshold: [0, 0.01, 0.5, 0.99, 1]\n    }\n  );\n  this.segments.forEach((s) => {\n    this.intersectionObserver?.observe(s);\n  });\n};\n_scrollLeft = new WeakMap();\n_scrollRight = new WeakMap();\n_updateScrollBtnState = new WeakMap();\n_updateScrollBtnStateDebounced = new WeakMap();\n_updateIndicator = new WeakMap();\n_handleSegmentClick = new WeakMap();\n_updateSelectedFromValue = new WeakMap();\nGdsSegmentedControl.styles = [tokens, unsafeCSS(style)];\n__decorateClass([\n  property({ reflect: true })\n], GdsSegmentedControl.prototype, \"size\", 2);\n__decorateClass([\n  property()\n], GdsSegmentedControl.prototype, \"value\", 1);\n__decorateClass([\n  query(\"slot\")\n], GdsSegmentedControl.prototype, \"_elSlot\", 2);\n__decorateClass([\n  query(\"#indicator\")\n], GdsSegmentedControl.prototype, \"_elIndicator\", 2);\n__decorateClass([\n  query(\"#track\")\n], GdsSegmentedControl.prototype, \"_elTrack\", 2);\n__decorateClass([\n  state()\n], GdsSegmentedControl.prototype, \"_showPrevButton\", 2);\n__decorateClass([\n  state()\n], GdsSegmentedControl.prototype, \"_showNextButton\", 2);\n__decorateClass([\n  resizeObserver(),\n  watch(\"value\")\n], GdsSegmentedControl.prototype, \"_recalculateMinWidth\", 1);\nGdsSegmentedControl = __decorateClass([\n  gdsCustomElement(\"gds-segmented-control\", {\n    dependsOn: [GdsSegment, IconChevronLeft, IconChevronRight]\n  }),\n  localized()\n], GdsSegmentedControl);\nexport {\n  GdsSegmentedControl\n};\n"],"names":[],"sourceRoot":""}