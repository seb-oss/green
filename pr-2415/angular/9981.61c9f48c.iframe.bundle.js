/*! For license information please see 9981.61c9f48c.iframe.bundle.js.LICENSE.txt */
"use strict";(self.webpackChunkgreen=self.webpackChunkgreen||[]).push([[9981],{"./node_modules/@angular/router/fesm2022/testing.mjs":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{__webpack_require__.d(__webpack_exports__,{c:()=>RouterTestingModule});var asyncToGenerator=__webpack_require__("./node_modules/@angular-devkit/build-angular/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js"),common=__webpack_require__("./node_modules/@angular/common/fesm2022/common.mjs"),core=__webpack_require__("./node_modules/@angular/core/fesm2022/core.mjs"),Subject=__webpack_require__("./node_modules/rxjs/dist/esm5/internal/Subject.js");class PlatformNavigation{static{this.ɵfac=function PlatformNavigation_Factory(__ngFactoryType__){return new(__ngFactoryType__||PlatformNavigation)}}static{this.ɵprov=core["ɵɵdefineInjectable"]({token:PlatformNavigation,factory:()=>window.navigation,providedIn:"platform"})}}("undefined"==typeof ngDevMode||ngDevMode)&&core["ɵsetClassMetadata"](PlatformNavigation,[{type:core.Injectable,args:[{providedIn:"platform",useFactory:()=>window.navigation}]}],null,null);class FakeNavigation{get currentEntry(){return this.entriesArr[this.currentEntryIndex]}get canGoBack(){return this.currentEntryIndex>0}get canGoForward(){return this.currentEntryIndex<this.entriesArr.length-1}constructor(window,startURL){this.window=window,this.entriesArr=[],this.currentEntryIndex=0,this.navigateEvent=void 0,this.traversalQueue=new Map,this.nextTraversal=Promise.resolve(),this.prospectiveEntryIndex=0,this.synchronousTraversals=!1,this.canSetInitialEntry=!0,this.eventTarget=this.window.document.createElement("div"),this.nextId=0,this.nextKey=0,this.disposed=!1,this.setInitialEntryForTesting(startURL)}setInitialEntryForTesting(url,options={historyState:null}){if(!this.canSetInitialEntry)throw new Error("setInitialEntryForTesting can only be called before any navigation has occurred");const currentInitialEntry=this.entriesArr[0];this.entriesArr[0]=new FakeNavigationHistoryEntry(new URL(url).toString(),{index:0,key:currentInitialEntry?.key??String(this.nextKey++),id:currentInitialEntry?.id??String(this.nextId++),sameDocument:!0,historyState:options?.historyState,state:options.state})}canSetInitialEntryForTesting(){return this.canSetInitialEntry}setSynchronousTraversalsForTesting(synchronousTraversals){this.synchronousTraversals=synchronousTraversals}entries(){return this.entriesArr.slice()}navigate(url,options){const fromUrl=new URL(this.currentEntry.url),toUrl=new URL(url,this.currentEntry.url);let navigationType;navigationType=options?.history&&"auto"!==options.history?options.history:fromUrl.toString()===toUrl.toString()?"replace":"push";const hashChange=isHashChange(fromUrl,toUrl),destination=new FakeNavigationDestination({url:toUrl.toString(),state:options?.state,sameDocument:hashChange,historyState:null}),result=new InternalNavigationResult;return this.userAgentNavigate(destination,result,{navigationType,cancelable:!0,canIntercept:!0,userInitiated:!1,hashChange,info:options?.info}),{committed:result.committed,finished:result.finished}}pushState(data,title,url){this.pushOrReplaceState("push",data,title,url)}replaceState(data,title,url){this.pushOrReplaceState("replace",data,title,url)}pushOrReplaceState(navigationType,data,_title,url){const fromUrl=new URL(this.currentEntry.url),toUrl=url?new URL(url,this.currentEntry.url):fromUrl,hashChange=isHashChange(fromUrl,toUrl),destination=new FakeNavigationDestination({url:toUrl.toString(),sameDocument:!0,historyState:data}),result=new InternalNavigationResult;this.userAgentNavigate(destination,result,{navigationType,cancelable:!0,canIntercept:!0,userInitiated:!1,hashChange,skipPopState:!0})}traverseTo(key,options){const fromUrl=new URL(this.currentEntry.url),entry=this.findEntry(key);if(!entry){const domException=new DOMException("Invalid key","InvalidStateError"),committed=Promise.reject(domException),finished=Promise.reject(domException);return committed.catch((()=>{})),finished.catch((()=>{})),{committed,finished}}if(entry===this.currentEntry)return{committed:Promise.resolve(this.currentEntry),finished:Promise.resolve(this.currentEntry)};if(this.traversalQueue.has(entry.key)){const existingResult=this.traversalQueue.get(entry.key);return{committed:existingResult.committed,finished:existingResult.finished}}const hashChange=isHashChange(fromUrl,new URL(entry.url,this.currentEntry.url)),destination=new FakeNavigationDestination({url:entry.url,state:entry.getState(),historyState:entry.getHistoryState(),key:entry.key,id:entry.id,index:entry.index,sameDocument:entry.sameDocument});this.prospectiveEntryIndex=entry.index;const result=new InternalNavigationResult;return this.traversalQueue.set(entry.key,result),this.runTraversal((()=>{this.traversalQueue.delete(entry.key),this.userAgentNavigate(destination,result,{navigationType:"traverse",cancelable:!0,canIntercept:!0,userInitiated:!1,hashChange,info:options?.info})})),{committed:result.committed,finished:result.finished}}back(options){if(0===this.currentEntryIndex){const domException=new DOMException("Cannot go back","InvalidStateError"),committed=Promise.reject(domException),finished=Promise.reject(domException);return committed.catch((()=>{})),finished.catch((()=>{})),{committed,finished}}const entry=this.entriesArr[this.currentEntryIndex-1];return this.traverseTo(entry.key,options)}forward(options){if(this.currentEntryIndex===this.entriesArr.length-1){const domException=new DOMException("Cannot go forward","InvalidStateError"),committed=Promise.reject(domException),finished=Promise.reject(domException);return committed.catch((()=>{})),finished.catch((()=>{})),{committed,finished}}const entry=this.entriesArr[this.currentEntryIndex+1];return this.traverseTo(entry.key,options)}go(direction){const targetIndex=this.prospectiveEntryIndex+direction;targetIndex>=this.entriesArr.length||targetIndex<0||(this.prospectiveEntryIndex=targetIndex,this.runTraversal((()=>{if(targetIndex>=this.entriesArr.length||targetIndex<0)return;const fromUrl=new URL(this.currentEntry.url),entry=this.entriesArr[targetIndex],hashChange=isHashChange(fromUrl,new URL(entry.url,this.currentEntry.url)),destination=new FakeNavigationDestination({url:entry.url,state:entry.getState(),historyState:entry.getHistoryState(),key:entry.key,id:entry.id,index:entry.index,sameDocument:entry.sameDocument}),result=new InternalNavigationResult;this.userAgentNavigate(destination,result,{navigationType:"traverse",cancelable:!0,canIntercept:!0,userInitiated:!1,hashChange})})))}runTraversal(traversal){this.synchronousTraversals?traversal():this.nextTraversal=this.nextTraversal.then((()=>new Promise((resolve=>{setTimeout((()=>{resolve(),traversal()}))}))))}addEventListener(type,callback,options){this.eventTarget.addEventListener(type,callback,options)}removeEventListener(type,callback,options){this.eventTarget.removeEventListener(type,callback,options)}dispatchEvent(event){return this.eventTarget.dispatchEvent(event)}dispose(){this.eventTarget=this.window.document.createElement("div"),this.disposed=!0}isDisposed(){return this.disposed}userAgentNavigate(destination,result,options){this.canSetInitialEntry=!1,this.navigateEvent&&(this.navigateEvent.cancel(new DOMException("Navigation was aborted","AbortError")),this.navigateEvent=void 0);const navigateEvent=function createFakeNavigateEvent({cancelable,canIntercept,userInitiated,hashChange,navigationType,signal,destination,info,sameDocument,skipPopState,result,userAgentCommit}){const event=new Event("navigate",{bubbles:!1,cancelable});event.canIntercept=canIntercept,event.userInitiated=userInitiated,event.hashChange=hashChange,event.navigationType=navigationType,event.signal=signal,event.destination=destination,event.info=info,event.downloadRequest=null,event.formData=null,event.sameDocument=sameDocument,event.skipPopState=skipPopState,event.commitOption="immediate";let handlerFinished,interceptCalled=!1,dispatchedNavigateEvent=!1,commitCalled=!1;return event.intercept=function(options){interceptCalled=!0,event.sameDocument=!0;const handler=options?.handler;if(handler&&(handlerFinished=handler()),options?.commit&&(event.commitOption=options.commit),void 0!==options?.focusReset||void 0!==options?.scroll)throw new Error("unimplemented")},event.scroll=function(){throw new Error("unimplemented")},event.commit=function(internal=!1){if(!internal&&!interceptCalled)throw new DOMException("Failed to execute 'commit' on 'NavigateEvent': intercept() must be called before commit().","InvalidStateError");if(!dispatchedNavigateEvent)throw new DOMException("Failed to execute 'commit' on 'NavigateEvent': commit() may not be called during event dispatch.","InvalidStateError");if(commitCalled)throw new DOMException("Failed to execute 'commit' on 'NavigateEvent': commit() already called.","InvalidStateError");commitCalled=!0,userAgentCommit()},event.cancel=function(reason){result.committedReject(reason),result.finishedReject(reason)},event.dispatchedNavigateEvent=function(){dispatchedNavigateEvent=!0,"after-transition"===event.commitOption&&handlerFinished?.then((()=>{commitCalled||event.commit(!0)}),(()=>{})),Promise.all([result.committed,handlerFinished]).then((([entry])=>{result.finishedResolve(entry)}),(reason=>{result.finishedReject(reason)}))},event.userAgentNavigated=function(entry){result.committedResolve(entry)},event}({navigationType:options.navigationType,cancelable:options.cancelable,canIntercept:options.canIntercept,userInitiated:options.userInitiated,hashChange:options.hashChange,signal:result.signal,destination,info:options.info,sameDocument:destination.sameDocument,skipPopState:options.skipPopState,result,userAgentCommit:()=>{this.userAgentCommit()}});this.navigateEvent=navigateEvent,this.eventTarget.dispatchEvent(navigateEvent),navigateEvent.dispatchedNavigateEvent(),"immediate"===navigateEvent.commitOption&&navigateEvent.commit(!0)}userAgentCommit(){if(!this.navigateEvent)return;const from=this.currentEntry;if(!this.navigateEvent.sameDocument){const error=new Error("Cannot navigate to a non-same-document URL.");throw this.navigateEvent.cancel(error),error}"push"===this.navigateEvent.navigationType||"replace"===this.navigateEvent.navigationType?this.userAgentPushOrReplace(this.navigateEvent.destination,{navigationType:this.navigateEvent.navigationType}):"traverse"===this.navigateEvent.navigationType&&this.userAgentTraverse(this.navigateEvent.destination),this.navigateEvent.userAgentNavigated(this.currentEntry);const currentEntryChangeEvent=function createFakeNavigationCurrentEntryChangeEvent({from,navigationType}){const event=new Event("currententrychange",{bubbles:!1,cancelable:!1});return event.from=from,event.navigationType=navigationType,event}({from,navigationType:this.navigateEvent.navigationType});if(this.eventTarget.dispatchEvent(currentEntryChangeEvent),!this.navigateEvent.skipPopState){const popStateEvent=function createPopStateEvent({state}){const event=new Event("popstate",{bubbles:!1,cancelable:!1});return event.state=state,event}({state:this.navigateEvent.destination.getHistoryState()});this.window.dispatchEvent(popStateEvent)}}userAgentPushOrReplace(destination,{navigationType}){"push"===navigationType&&(this.currentEntryIndex++,this.prospectiveEntryIndex=this.currentEntryIndex);const index=this.currentEntryIndex,key="push"===navigationType?String(this.nextKey++):this.currentEntry.key,entry=new FakeNavigationHistoryEntry(destination.url,{id:String(this.nextId++),key,index,sameDocument:!0,state:destination.getState(),historyState:destination.getHistoryState()});"push"===navigationType?this.entriesArr.splice(index,1/0,entry):this.entriesArr[index]=entry}userAgentTraverse(destination){this.currentEntryIndex=destination.index}findEntry(key){for(const entry of this.entriesArr)if(entry.key===key)return entry}set onnavigate(_handler){throw new Error("unimplemented")}get onnavigate(){throw new Error("unimplemented")}set oncurrententrychange(_handler){throw new Error("unimplemented")}get oncurrententrychange(){throw new Error("unimplemented")}set onnavigatesuccess(_handler){throw new Error("unimplemented")}get onnavigatesuccess(){throw new Error("unimplemented")}set onnavigateerror(_handler){throw new Error("unimplemented")}get onnavigateerror(){throw new Error("unimplemented")}get transition(){throw new Error("unimplemented")}updateCurrentEntry(_options){throw new Error("unimplemented")}reload(_options){throw new Error("unimplemented")}}class FakeNavigationHistoryEntry{constructor(url,{id,key,index,sameDocument,state,historyState}){this.url=url,this.ondispose=null,this.id=id,this.key=key,this.index=index,this.sameDocument=sameDocument,this.state=state,this.historyState=historyState}getState(){return this.state?JSON.parse(JSON.stringify(this.state)):this.state}getHistoryState(){return this.historyState?JSON.parse(JSON.stringify(this.historyState)):this.historyState}addEventListener(type,callback,options){throw new Error("unimplemented")}removeEventListener(type,callback,options){throw new Error("unimplemented")}dispatchEvent(event){throw new Error("unimplemented")}}class FakeNavigationDestination{constructor({url,sameDocument,historyState,state,key=null,id=null,index=-1}){this.url=url,this.sameDocument=sameDocument,this.state=state,this.historyState=historyState,this.key=key,this.id=id,this.index=index}getState(){return this.state}getHistoryState(){return this.historyState}}function isHashChange(from,to){return to.hash!==from.hash&&to.hostname===from.hostname&&to.pathname===from.pathname&&to.search===from.search}class InternalNavigationResult{get signal(){return this.abortController.signal}constructor(){var _this=this;this.abortController=new AbortController,this.committed=new Promise(((resolve,reject)=>{this.committedResolve=resolve,this.committedReject=reject})),this.finished=new Promise(function(){var _ref=(0,asyncToGenerator.A)((function*(resolve,reject){_this.finishedResolve=resolve,_this.finishedReject=reason=>{reject(reason),_this.abortController.abort(reason)}}));return function(_x,_x2){return _ref.apply(this,arguments)}}()),this.committed.catch((()=>{})),this.finished.catch((()=>{}))}}const urlParse=/^(([^:\/?#]+):)?(\/\/([^\/?#]*))?([^?#]*)(\?([^#]*))?(#(.*))?/;function parseUrl(urlStr,baseHref){let serverBase,parsedUrl;/^((http[s]?|ftp):\/\/)/.test(urlStr)||(serverBase="http://empty.com/");try{parsedUrl=new URL(urlStr,serverBase)}catch(e){const result=urlParse.exec(serverBase||""+urlStr);if(!result)throw new Error(`Invalid URL: ${urlStr} with base: ${baseHref}`);const hostSplit=result[4].split(":");parsedUrl={protocol:result[1],hostname:hostSplit[0],port:hostSplit[1]||"",pathname:result[5],search:result[6],hash:result[8]}}return parsedUrl.pathname&&0===parsedUrl.pathname.indexOf(baseHref)&&(parsedUrl.pathname=parsedUrl.pathname.substring(baseHref.length)),{hostname:!serverBase&&parsedUrl.hostname||"",protocol:!serverBase&&parsedUrl.protocol||"",port:!serverBase&&parsedUrl.port||"",pathname:parsedUrl.pathname||"/",search:parsedUrl.search||"",hash:parsedUrl.hash||""}}const MOCK_PLATFORM_LOCATION_CONFIG=new core.InjectionToken("MOCK_PLATFORM_LOCATION_CONFIG");class MockPlatformLocation{constructor(config){if(this.baseHref="",this.hashUpdate=new Subject.B,this.popStateSubject=new Subject.B,this.urlChangeIndex=0,this.urlChanges=[{hostname:"",protocol:"",port:"",pathname:"/",search:"",hash:"",state:null}],config){this.baseHref=config.appBaseHref||"";const parsedChanges=this.parseChanges(null,config.startUrl||"http://_empty_/",this.baseHref);this.urlChanges[0]={...parsedChanges}}}get hostname(){return this.urlChanges[this.urlChangeIndex].hostname}get protocol(){return this.urlChanges[this.urlChangeIndex].protocol}get port(){return this.urlChanges[this.urlChangeIndex].port}get pathname(){return this.urlChanges[this.urlChangeIndex].pathname}get search(){return this.urlChanges[this.urlChangeIndex].search}get hash(){return this.urlChanges[this.urlChangeIndex].hash}get state(){return this.urlChanges[this.urlChangeIndex].state}getBaseHrefFromDOM(){return this.baseHref}onPopState(fn){const subscription=this.popStateSubject.subscribe(fn);return()=>subscription.unsubscribe()}onHashChange(fn){const subscription=this.hashUpdate.subscribe(fn);return()=>subscription.unsubscribe()}get href(){let url=`${this.protocol}//${this.hostname}${this.port?":"+this.port:""}`;return url+=`${"/"===this.pathname?"":this.pathname}${this.search}${this.hash}`,url}get url(){return`${this.pathname}${this.search}${this.hash}`}parseChanges(state,url,baseHref=""){return state=JSON.parse(JSON.stringify(state)),{...parseUrl(url,baseHref),state}}replaceState(state,title,newUrl){const{pathname,search,state:parsedState,hash}=this.parseChanges(state,newUrl);this.urlChanges[this.urlChangeIndex]={...this.urlChanges[this.urlChangeIndex],pathname,search,hash,state:parsedState}}pushState(state,title,newUrl){const{pathname,search,state:parsedState,hash}=this.parseChanges(state,newUrl);this.urlChangeIndex>0&&this.urlChanges.splice(this.urlChangeIndex+1),this.urlChanges.push({...this.urlChanges[this.urlChangeIndex],pathname,search,hash,state:parsedState}),this.urlChangeIndex=this.urlChanges.length-1}forward(){const oldUrl=this.url,oldHash=this.hash;this.urlChangeIndex<this.urlChanges.length&&this.urlChangeIndex++,this.emitEvents(oldHash,oldUrl)}back(){const oldUrl=this.url,oldHash=this.hash;this.urlChangeIndex>0&&this.urlChangeIndex--,this.emitEvents(oldHash,oldUrl)}historyGo(relativePosition=0){const oldUrl=this.url,oldHash=this.hash,nextPageIndex=this.urlChangeIndex+relativePosition;nextPageIndex>=0&&nextPageIndex<this.urlChanges.length&&(this.urlChangeIndex=nextPageIndex),this.emitEvents(oldHash,oldUrl)}getState(){return this.state}emitEvents(oldHash,oldUrl){this.popStateSubject.next({type:"popstate",state:this.getState(),oldUrl,newUrl:this.url}),oldHash!==this.hash&&this.hashUpdate.next({type:"hashchange",state:null,oldUrl,newUrl:this.url})}static{this.ɵfac=function MockPlatformLocation_Factory(__ngFactoryType__){return new(__ngFactoryType__||MockPlatformLocation)(core["ɵɵinject"](MOCK_PLATFORM_LOCATION_CONFIG,8))}}static{this.ɵprov=core["ɵɵdefineInjectable"]({token:MockPlatformLocation,factory:MockPlatformLocation.ɵfac})}}("undefined"==typeof ngDevMode||ngDevMode)&&core["ɵsetClassMetadata"](MockPlatformLocation,[{type:core.Injectable}],(()=>[{type:void 0,decorators:[{type:core.Inject,args:[MOCK_PLATFORM_LOCATION_CONFIG]},{type:core.Optional}]}]),null);class FakeNavigationPlatformLocation{constructor(){if(this._platformNavigation=(0,core.inject)(common["ɵPlatformNavigation"]),this.window=(0,core.inject)(common.DOCUMENT).defaultView,this.config=(0,core.inject)(MOCK_PLATFORM_LOCATION_CONFIG,{optional:!0}),!(this._platformNavigation instanceof FakeNavigation))throw new Error("FakePlatformNavigation cannot be used without FakeNavigation. Use `provideFakeNavigation` to have all these services provided together.")}getBaseHrefFromDOM(){return this.config?.appBaseHref??""}onPopState(fn){return this.window.addEventListener("popstate",fn),()=>this.window.removeEventListener("popstate",fn)}onHashChange(fn){return this.window.addEventListener("hashchange",fn),()=>this.window.removeEventListener("hashchange",fn)}get href(){return this._platformNavigation.currentEntry.url}get protocol(){return new URL(this._platformNavigation.currentEntry.url).protocol}get hostname(){return new URL(this._platformNavigation.currentEntry.url).hostname}get port(){return new URL(this._platformNavigation.currentEntry.url).port}get pathname(){return new URL(this._platformNavigation.currentEntry.url).pathname}get search(){return new URL(this._platformNavigation.currentEntry.url).search}get hash(){return new URL(this._platformNavigation.currentEntry.url).hash}pushState(state,title,url){this._platformNavigation.pushState(state,title,url)}replaceState(state,title,url){this._platformNavigation.replaceState(state,title,url)}forward(){this._platformNavigation.forward()}back(){this._platformNavigation.back()}historyGo(relativePosition=0){this._platformNavigation.go(relativePosition)}getState(){return this._platformNavigation.currentEntry.getHistoryState()}static{this.ɵfac=function FakeNavigationPlatformLocation_Factory(__ngFactoryType__){return new(__ngFactoryType__||FakeNavigationPlatformLocation)}}static{this.ɵprov=core["ɵɵdefineInjectable"]({token:FakeNavigationPlatformLocation,factory:FakeNavigationPlatformLocation.ɵfac})}}("undefined"==typeof ngDevMode||ngDevMode)&&core["ɵsetClassMetadata"](FakeNavigationPlatformLocation,[{type:core.Injectable}],(()=>[]),null);class SpyLocation{constructor(){this.urlChanges=[],this._history=[new LocationState("","",null)],this._historyIndex=0,this._subject=new core.EventEmitter,this._basePath="",this._locationStrategy=null,this._urlChangeListeners=[],this._urlChangeSubscription=null}ngOnDestroy(){this._urlChangeSubscription?.unsubscribe(),this._urlChangeListeners=[]}setInitialPath(url){this._history[this._historyIndex].path=url}setBaseHref(url){this._basePath=url}path(){return this._history[this._historyIndex].path}getState(){return this._history[this._historyIndex].state}isCurrentPathEqualTo(path,query=""){const givenPath=path.endsWith("/")?path.substring(0,path.length-1):path;return(this.path().endsWith("/")?this.path().substring(0,this.path().length-1):this.path())==givenPath+(query.length>0?"?"+query:"")}simulateUrlPop(pathname){this._subject.emit({url:pathname,pop:!0,type:"popstate"})}simulateHashChange(pathname){const path=this.prepareExternalUrl(pathname);this.pushHistory(path,"",null),this.urlChanges.push("hash: "+pathname),this._subject.emit({url:pathname,pop:!0,type:"popstate"}),this._subject.emit({url:pathname,pop:!0,type:"hashchange"})}prepareExternalUrl(url){return url.length>0&&!url.startsWith("/")&&(url="/"+url),this._basePath+url}go(path,query="",state=null){path=this.prepareExternalUrl(path),this.pushHistory(path,query,state);const locationState=this._history[this._historyIndex-1];if(locationState.path==path&&locationState.query==query)return;const url=path+(query.length>0?"?"+query:"");this.urlChanges.push(url),this._notifyUrlChangeListeners(path+(0,common["ɵnormalizeQueryParams"])(query),state)}replaceState(path,query="",state=null){path=this.prepareExternalUrl(path);const history=this._history[this._historyIndex];if(history.state=state,history.path==path&&history.query==query)return;history.path=path,history.query=query;const url=path+(query.length>0?"?"+query:"");this.urlChanges.push("replace: "+url),this._notifyUrlChangeListeners(path+(0,common["ɵnormalizeQueryParams"])(query),state)}forward(){this._historyIndex<this._history.length-1&&(this._historyIndex++,this._subject.emit({url:this.path(),state:this.getState(),pop:!0,type:"popstate"}))}back(){this._historyIndex>0&&(this._historyIndex--,this._subject.emit({url:this.path(),state:this.getState(),pop:!0,type:"popstate"}))}historyGo(relativePosition=0){const nextPageIndex=this._historyIndex+relativePosition;nextPageIndex>=0&&nextPageIndex<this._history.length&&(this._historyIndex=nextPageIndex,this._subject.emit({url:this.path(),state:this.getState(),pop:!0,type:"popstate"}))}onUrlChange(fn){return this._urlChangeListeners.push(fn),this._urlChangeSubscription??=this.subscribe((v=>{this._notifyUrlChangeListeners(v.url,v.state)})),()=>{const fnIndex=this._urlChangeListeners.indexOf(fn);this._urlChangeListeners.splice(fnIndex,1),0===this._urlChangeListeners.length&&(this._urlChangeSubscription?.unsubscribe(),this._urlChangeSubscription=null)}}_notifyUrlChangeListeners(url="",state){this._urlChangeListeners.forEach((fn=>fn(url,state)))}subscribe(onNext,onThrow,onReturn){return this._subject.subscribe({next:onNext,error:onThrow,complete:onReturn})}normalize(url){return null}pushHistory(path,query,state){this._historyIndex>0&&this._history.splice(this._historyIndex+1),this._history.push(new LocationState(path,query,state)),this._historyIndex=this._history.length-1}static{this.ɵfac=function SpyLocation_Factory(__ngFactoryType__){return new(__ngFactoryType__||SpyLocation)}}static{this.ɵprov=core["ɵɵdefineInjectable"]({token:SpyLocation,factory:SpyLocation.ɵfac})}}("undefined"==typeof ngDevMode||ngDevMode)&&core["ɵsetClassMetadata"](SpyLocation,[{type:core.Injectable}],null,null);class LocationState{constructor(path,query,state){this.path=path,this.query=query,this.state=state}}class MockLocationStrategy extends common.LocationStrategy{constructor(){super(),this.internalBaseHref="/",this.internalPath="/",this.internalTitle="",this.urlChanges=[],this._subject=new core.EventEmitter,this.stateChanges=[]}simulatePopState(url){this.internalPath=url,this._subject.emit(new _MockPopStateEvent(this.path()))}path(includeHash=!1){return this.internalPath}prepareExternalUrl(internal){return internal.startsWith("/")&&this.internalBaseHref.endsWith("/")?this.internalBaseHref+internal.substring(1):this.internalBaseHref+internal}pushState(ctx,title,path,query){this.stateChanges.push(ctx),this.internalTitle=title;const url=path+(query.length>0?"?"+query:"");this.internalPath=url;const externalUrl=this.prepareExternalUrl(url);this.urlChanges.push(externalUrl)}replaceState(ctx,title,path,query){this.stateChanges[(this.stateChanges.length||1)-1]=ctx,this.internalTitle=title;const url=path+(query.length>0?"?"+query:"");this.internalPath=url;const externalUrl=this.prepareExternalUrl(url);this.urlChanges.push("replace: "+externalUrl)}onPopState(fn){this._subject.subscribe({next:fn})}getBaseHref(){return this.internalBaseHref}back(){if(this.urlChanges.length>0){this.urlChanges.pop(),this.stateChanges.pop();const nextUrl=this.urlChanges.length>0?this.urlChanges[this.urlChanges.length-1]:"";this.simulatePopState(nextUrl)}}forward(){throw"not implemented"}getState(){return this.stateChanges[(this.stateChanges.length||1)-1]}static{this.ɵfac=function MockLocationStrategy_Factory(__ngFactoryType__){return new(__ngFactoryType__||MockLocationStrategy)}}static{this.ɵprov=core["ɵɵdefineInjectable"]({token:MockLocationStrategy,factory:MockLocationStrategy.ɵfac})}}("undefined"==typeof ngDevMode||ngDevMode)&&core["ɵsetClassMetadata"](MockLocationStrategy,[{type:core.Injectable}],(()=>[]),null);class _MockPopStateEvent{constructor(newUrl){this.newUrl=newUrl,this.pop=!0,this.type="popstate"}}function provideLocationMocks(){return[{provide:common.Location,useClass:SpyLocation},{provide:common.LocationStrategy,useClass:MockLocationStrategy}]}var fesm2022_router=__webpack_require__("./node_modules/@angular/router/fesm2022/router.mjs"),Subscription=__webpack_require__("./node_modules/rxjs/dist/esm5/internal/Subscription.js"),compiler=__webpack_require__("./node_modules/@angular/compiler/fesm2022/compiler.mjs");class DeferBlockFixture{constructor(block,componentFixture){this.block=block,this.componentFixture=componentFixture}render(state){var _this=this;return(0,asyncToGenerator.A)((function*(){if(!function hasStateTemplate(state,block){switch(state){case core["ɵDeferBlockState"].Placeholder:return null!==block.tDetails.placeholderTmplIndex;case core["ɵDeferBlockState"].Loading:return null!==block.tDetails.loadingTmplIndex;case core["ɵDeferBlockState"].Error:return null!==block.tDetails.errorTmplIndex;case core["ɵDeferBlockState"].Complete:return!0;default:return!1}}(state,_this.block)){const stateAsString=function getDeferBlockStateNameFromEnum(state){switch(state){case core["ɵDeferBlockState"].Placeholder:return"Placeholder";case core["ɵDeferBlockState"].Loading:return"Loading";case core["ɵDeferBlockState"].Error:return"Error";default:return"Main"}}(state);throw new Error(`Tried to render this defer block in the \`${stateAsString}\` state, but there was no @${stateAsString.toLowerCase()} block defined in a template.`)}state===core["ɵDeferBlockState"].Complete&&(yield(0,core["ɵtriggerResourceLoading"])(_this.block.tDetails,_this.block.lView,_this.block.tNode));(0,core["ɵrenderDeferBlockState"])(state,_this.block.tNode,_this.block.lContainer,!0),_this.componentFixture.detectChanges()}))()}getDeferBlocks(){const deferBlocks=[],deferBlockFixtures=[];if(this.block.lContainer.length>=core["ɵCONTAINER_HEADER_OFFSET"]){const lView=this.block.lContainer[core["ɵCONTAINER_HEADER_OFFSET"]];(0,core["ɵgetDeferBlocks"])(lView,deferBlocks);for(const block of deferBlocks)deferBlockFixtures.push(new DeferBlockFixture(block,this.componentFixture))}return Promise.resolve(deferBlockFixtures)}}const DEFER_BLOCK_DEFAULT_BEHAVIOR=core["ɵDeferBlockBehavior"].Playthrough;class TestComponentRenderer{insertRootElement(rootElementId){}removeAllRootElements(){}}const ComponentFixtureAutoDetect=new core.InjectionToken("ComponentFixtureAutoDetect"),ComponentFixtureNoNgZone=new core.InjectionToken("ComponentFixtureNoNgZone"),RETHROW_APPLICATION_ERRORS=new core.InjectionToken("rethrow application errors");class TestBedApplicationErrorHandler{constructor(){this.zone=(0,core.inject)(core.NgZone),this.userErrorHandler=(0,core.inject)(core.ErrorHandler),this.whenStableRejectFunctions=new Set}handleError(e){try{this.zone.runOutsideAngular((()=>this.userErrorHandler.handleError(e)))}catch(userError){e=userError}if(!(this.whenStableRejectFunctions.size>0))throw e;for(const fn of this.whenStableRejectFunctions.values())fn(e);this.whenStableRejectFunctions.clear()}static{this.ɵfac=core["ɵɵngDeclareFactory"]({minVersion:"12.0.0",version:"18.2.13",ngImport:core,type:TestBedApplicationErrorHandler,deps:[],target:core["ɵɵFactoryTarget"].Injectable})}static{this.ɵprov=core["ɵɵngDeclareInjectable"]({minVersion:"12.0.0",version:"18.2.13",ngImport:core,type:TestBedApplicationErrorHandler})}}core["ɵɵngDeclareClassMetadata"]({minVersion:"12.0.0",version:"18.2.13",ngImport:core,type:TestBedApplicationErrorHandler,decorators:[{type:core.Injectable}]});class ComponentFixture{constructor(componentRef){this.componentRef=componentRef,this._isDestroyed=!1,this._noZoneOptionIsSet=(0,core.inject)(ComponentFixtureNoNgZone,{optional:!0}),this._ngZone=this._noZoneOptionIsSet?new core["ɵNoopNgZone"]:(0,core.inject)(core.NgZone),this._effectRunner=(0,core.inject)(core["ɵEffectScheduler"]),this._appRef=(0,core.inject)(core.ApplicationRef),this._testAppRef=this._appRef,this.pendingTasks=(0,core.inject)(core["ɵPendingTasks"]),this.appErrorHandler=(0,core.inject)(TestBedApplicationErrorHandler),this.ngZone=this._noZoneOptionIsSet?null:this._ngZone,this.changeDetectorRef=componentRef.changeDetectorRef,this.elementRef=componentRef.location,this.debugElement=(0,core.getDebugNode)(this.elementRef.nativeElement),this.componentInstance=componentRef.instance,this.nativeElement=this.elementRef.nativeElement,this.componentRef=componentRef}checkNoChanges(){this.changeDetectorRef.checkNoChanges()}isStable(){return!this.pendingTasks.hasPendingTasks.value}whenStable(){return this.isStable()?Promise.resolve(!1):new Promise(((resolve,reject)=>{this.appErrorHandler.whenStableRejectFunctions.add(reject),this._appRef.whenStable().then((()=>{this.appErrorHandler.whenStableRejectFunctions.delete(reject),resolve(!0)}))}))}getDeferBlocks(){const deferBlocks=[],lView=this.componentRef.hostView._lView;(0,core["ɵgetDeferBlocks"])(lView,deferBlocks);const deferBlockFixtures=[];for(const block of deferBlocks)deferBlockFixtures.push(new DeferBlockFixture(block,this));return Promise.resolve(deferBlockFixtures)}_getRenderer(){return void 0===this._renderer&&(this._renderer=this.componentRef.injector.get(core.RendererFactory2,null)),this._renderer}whenRenderingDone(){const renderer=this._getRenderer();return renderer&&renderer.whenRenderingDone?renderer.whenRenderingDone():this.whenStable()}destroy(){this._isDestroyed||(this.componentRef.destroy(),this._isDestroyed=!0)}}class ScheduledComponentFixture extends ComponentFixture{constructor(){super(...arguments),this._autoDetect=(0,core.inject)(ComponentFixtureAutoDetect,{optional:!0})??!0}initialize(){this._autoDetect&&this._appRef.attachView(this.componentRef.hostView)}detectChanges(checkNoChanges=!0){if(!checkNoChanges)throw new Error("Cannot disable `checkNoChanges` in this configuration. Use `fixture.componentRef.hostView.changeDetectorRef.detectChanges()` instead.");this._effectRunner.flush(),this._appRef.tick(),this._effectRunner.flush()}autoDetectChanges(autoDetect=!0){if(!autoDetect)throw new Error("Cannot disable autoDetect after it has been enabled when using the zoneless scheduler. To disable autoDetect, add `{provide: ComponentFixtureAutoDetect, useValue: false}` to the TestBed providers.");this._autoDetect||(this._autoDetect=autoDetect,this._appRef.attachView(this.componentRef.hostView)),this.detectChanges()}}class PseudoApplicationComponentFixture extends ComponentFixture{constructor(){super(...arguments),this._subscriptions=new Subscription.yU,this._autoDetect=(0,core.inject)(ComponentFixtureAutoDetect,{optional:!0})??!1,this.afterTickSubscription=void 0,this.beforeRenderSubscription=void 0}initialize(){this._autoDetect&&this.subscribeToAppRefEvents(),this.componentRef.hostView.onDestroy((()=>{this.unsubscribeFromAppRefEvents()})),this._ngZone.runOutsideAngular((()=>{this._subscriptions.add(this._ngZone.onError.subscribe({next:error=>{throw error}}))}))}detectChanges(checkNoChanges=!0){this._effectRunner.flush(),this._ngZone.run((()=>{this.changeDetectorRef.detectChanges(),checkNoChanges&&this.checkNoChanges()})),this._effectRunner.flush()}autoDetectChanges(autoDetect=!0){if(this._noZoneOptionIsSet)throw new Error("Cannot call autoDetectChanges when ComponentFixtureNoNgZone is set.");autoDetect!==this._autoDetect&&(autoDetect?this.subscribeToAppRefEvents():this.unsubscribeFromAppRefEvents()),this._autoDetect=autoDetect,this.detectChanges()}subscribeToAppRefEvents(){this._ngZone.runOutsideAngular((()=>{this.afterTickSubscription=this._testAppRef.afterTick.subscribe((()=>{this.checkNoChanges()})),this.beforeRenderSubscription=this._testAppRef.beforeRender.subscribe((isFirstPass=>{try{(0,core["ɵdetectChangesInViewIfRequired"])(this.componentRef.hostView._lView,this.componentRef.hostView.notifyErrorHandler,isFirstPass,!1)}catch(e){throw this.unsubscribeFromAppRefEvents(),e}})),this._testAppRef.externalTestViews.add(this.componentRef.hostView)}))}unsubscribeFromAppRefEvents(){this.afterTickSubscription?.unsubscribe(),this.beforeRenderSubscription?.unsubscribe(),this.afterTickSubscription=void 0,this.beforeRenderSubscription=void 0,this._testAppRef.externalTestViews.delete(this.componentRef.hostView)}destroy(){this.unsubscribeFromAppRefEvents(),this._subscriptions.unsubscribe(),super.destroy()}}const _Zone="undefined"!=typeof Zone?Zone:null,fakeAsyncTestModule=_Zone&&_Zone[_Zone.__symbol__("fakeAsyncTest")];let _nextReferenceId=0;class MetadataOverrider{constructor(){this._references=new Map}overrideMetadata(metadataClass,oldMetadata,override){const props={};if(oldMetadata&&function _valueProps(obj){const props=[];Object.keys(obj).forEach((prop=>{prop.startsWith("_")||props.push(prop)}));let proto=obj;for(;proto=Object.getPrototypeOf(proto);)Object.keys(proto).forEach((protoProp=>{const desc=Object.getOwnPropertyDescriptor(proto,protoProp);!protoProp.startsWith("_")&&desc&&"get"in desc&&props.push(protoProp)}));return props}(oldMetadata).forEach((prop=>props[prop]=oldMetadata[prop])),override.set){if(override.remove||override.add)throw new Error(`Cannot set and add/remove ${(0,core["ɵstringify"])(metadataClass)} at the same time!`);!function setMetadata(metadata,set){for(const prop in set)metadata[prop]=set[prop]}(props,override.set)}return override.remove&&function removeMetadata(metadata,remove,references){const removeObjects=new Set;for(const prop in remove){const removeValue=remove[prop];Array.isArray(removeValue)?removeValue.forEach((value=>{removeObjects.add(_propHashKey(prop,value,references))})):removeObjects.add(_propHashKey(prop,removeValue,references))}for(const prop in metadata){const propValue=metadata[prop];Array.isArray(propValue)?metadata[prop]=propValue.filter((value=>!removeObjects.has(_propHashKey(prop,value,references)))):removeObjects.has(_propHashKey(prop,propValue,references))&&(metadata[prop]=void 0)}}(props,override.remove,this._references),override.add&&function addMetadata(metadata,add){for(const prop in add){const addValue=add[prop],propValue=metadata[prop];null!=propValue&&Array.isArray(propValue)?metadata[prop]=propValue.concat(addValue):metadata[prop]=addValue}}(props,override.add),new metadataClass(props)}}function _propHashKey(propName,propValue,references){let nextObjectId=0;const objectIds=new Map;return`${propName}:${JSON.stringify(propValue,((key,value)=>null!==value&&"object"==typeof value?objectIds.has(value)?objectIds.get(value):(objectIds.set(value,"ɵobj#"+nextObjectId++),value):("function"==typeof value&&(value=function _serializeReference(ref,references){let id=references.get(ref);id||(id=`${(0,core["ɵstringify"])(ref)}${_nextReferenceId++}`,references.set(ref,id));return id}(value,references)),value)))}`}const reflection=new core["ɵReflectionCapabilities"];class OverrideResolver{constructor(){this.overrides=new Map,this.resolved=new Map}addOverride(type,override){const overrides=this.overrides.get(type)||[];overrides.push(override),this.overrides.set(type,overrides),this.resolved.delete(type)}setOverrides(overrides){this.overrides.clear(),overrides.forEach((([type,override])=>{this.addOverride(type,override)}))}getAnnotation(type){const annotations=reflection.annotations(type);for(let i=annotations.length-1;i>=0;i--){const annotation=annotations[i];if(annotation instanceof core.Directive||annotation instanceof core.Component||annotation instanceof core.Pipe||annotation instanceof core.NgModule)return annotation instanceof this.type?annotation:null}return null}resolve(type){let resolved=this.resolved.get(type)||null;if(!resolved){if(resolved=this.getAnnotation(type),resolved){const overrides=this.overrides.get(type);if(overrides){const overrider=new MetadataOverrider;overrides.forEach((override=>{resolved=overrider.overrideMetadata(this.type,resolved,override)}))}}this.resolved.set(type,resolved)}return resolved}}class DirectiveResolver extends OverrideResolver{get type(){return core.Directive}}class ComponentResolver extends OverrideResolver{get type(){return core.Component}}class PipeResolver extends OverrideResolver{get type(){return core.Pipe}}class NgModuleResolver extends OverrideResolver{get type(){return core.NgModule}}var TestingModuleOverride;function assertNoStandaloneComponents(types,resolver,location){types.forEach((type=>{if(!(0,core["ɵgetAsyncClassMetadataFn"])(type)){const component=resolver.resolve(type);if(component&&component.standalone)throw new Error((0,core["ɵgenerateStandaloneInDeclarationsError"])(type,location))}}))}!function(TestingModuleOverride){TestingModuleOverride[TestingModuleOverride.DECLARATION=0]="DECLARATION",TestingModuleOverride[TestingModuleOverride.OVERRIDE_TEMPLATE=1]="OVERRIDE_TEMPLATE"}(TestingModuleOverride||(TestingModuleOverride={}));class TestBedCompiler{constructor(platform,additionalModuleTypes){this.platform=platform,this.additionalModuleTypes=additionalModuleTypes,this.originalComponentResolutionQueue=null,this.declarations=[],this.imports=[],this.providers=[],this.schemas=[],this.pendingComponents=new Set,this.pendingDirectives=new Set,this.pendingPipes=new Set,this.componentsWithAsyncMetadata=new Set,this.seenComponents=new Set,this.seenDirectives=new Set,this.overriddenModules=new Set,this.existingComponentStyles=new Map,this.resolvers=function initResolvers(){return{module:new NgModuleResolver,component:new ComponentResolver,directive:new DirectiveResolver,pipe:new PipeResolver}}(),this.componentToModuleScope=new Map,this.initialNgDefs=new Map,this.defCleanupOps=[],this._injector=null,this.compilerProviders=null,this.providerOverrides=[],this.rootProviderOverrides=[],this.providerOverridesByModule=new Map,this.providerOverridesByToken=new Map,this.scopesWithOverriddenProviders=new Set,this.testModuleRef=null,this.deferBlockBehavior=DEFER_BLOCK_DEFAULT_BEHAVIOR;this.testModuleType=class DynamicTestModule{}}setCompilerProviders(providers){this.compilerProviders=providers,this._injector=null}configureTestingModule(moduleDef){void 0!==moduleDef.declarations&&(assertNoStandaloneComponents(moduleDef.declarations,this.resolvers.component,'"TestBed.configureTestingModule" call'),this.queueTypeArray(moduleDef.declarations,TestingModuleOverride.DECLARATION),this.declarations.push(...moduleDef.declarations)),void 0!==moduleDef.imports&&(this.queueTypesFromModulesArray(moduleDef.imports),this.imports.push(...moduleDef.imports)),void 0!==moduleDef.providers&&this.providers.push(...moduleDef.providers),this.providers.push({provide:RETHROW_APPLICATION_ERRORS,useValue:moduleDef._rethrowApplicationTickErrors??!1}),void 0!==moduleDef.schemas&&this.schemas.push(...moduleDef.schemas),this.deferBlockBehavior=moduleDef.deferBlockBehavior??DEFER_BLOCK_DEFAULT_BEHAVIOR}overrideModule(ngModule,override){core["ɵUSE_RUNTIME_DEPS_TRACKER_FOR_JIT"]&&core["ɵdepsTracker"].clearScopeCacheFor(ngModule),this.overriddenModules.add(ngModule),this.resolvers.module.addOverride(ngModule,override);const metadata=this.resolvers.module.resolve(ngModule);if(null===metadata)throw invalidTypeError(ngModule.name,"NgModule");this.recompileNgModule(ngModule,metadata),this.queueTypesFromModulesArray([ngModule])}overrideComponent(component,override){this.verifyNoStandaloneFlagOverrides(component,override),this.resolvers.component.addOverride(component,override),this.pendingComponents.add(component),this.maybeRegisterComponentWithAsyncMetadata(component)}overrideDirective(directive,override){this.verifyNoStandaloneFlagOverrides(directive,override),this.resolvers.directive.addOverride(directive,override),this.pendingDirectives.add(directive)}overridePipe(pipe,override){this.verifyNoStandaloneFlagOverrides(pipe,override),this.resolvers.pipe.addOverride(pipe,override),this.pendingPipes.add(pipe)}verifyNoStandaloneFlagOverrides(type,override){if(override.add?.hasOwnProperty("standalone")||override.set?.hasOwnProperty("standalone")||override.remove?.hasOwnProperty("standalone"))throw new Error(`An override for the ${type.name} class has the \`standalone\` flag. Changing the \`standalone\` flag via TestBed overrides is not supported.`)}overrideProvider(token,provider){let providerDef;providerDef=void 0!==provider.useFactory?{provide:token,useFactory:provider.useFactory,deps:provider.deps||[],multi:provider.multi}:void 0!==provider.useValue?{provide:token,useValue:provider.useValue,multi:provider.multi}:{provide:token};const injectableDef="string"!=typeof token?(0,core["ɵgetInjectableDef"])(token):null,providedIn=null===injectableDef?null:(0,core.resolveForwardRef)(injectableDef.providedIn);if(("root"===providedIn?this.rootProviderOverrides:this.providerOverrides).push(providerDef),this.providerOverridesByToken.set(token,providerDef),null!==injectableDef&&null!==providedIn&&"string"!=typeof providedIn){const existingOverrides=this.providerOverridesByModule.get(providedIn);void 0!==existingOverrides?existingOverrides.push(providerDef):this.providerOverridesByModule.set(providedIn,[providerDef])}}overrideTemplateUsingTestingModule(type,template){const def=type[core["ɵNG_COMP_DEF"]],overrideStyleUrls=!!def&&!(0,core["ɵisComponentDefPendingResolution"])(type)&&(()=>{const metadata=this.resolvers.component.resolve(type);return!!metadata.styleUrl||!!metadata.styleUrls?.length})(),override=overrideStyleUrls?{template,styles:[],styleUrls:[],styleUrl:void 0}:{template};this.overrideComponent(type,{set:override}),overrideStyleUrls&&def.styles&&def.styles.length>0&&this.existingComponentStyles.set(type,def.styles),this.componentToModuleScope.set(type,TestingModuleOverride.OVERRIDE_TEMPLATE)}resolvePendingComponentsWithAsyncMetadata(){var _this2=this;return(0,asyncToGenerator.A)((function*(){if(0===_this2.componentsWithAsyncMetadata.size)return;const promises=[];for(const component of _this2.componentsWithAsyncMetadata){const asyncMetadataFn=(0,core["ɵgetAsyncClassMetadataFn"])(component);asyncMetadataFn&&promises.push(asyncMetadataFn())}_this2.componentsWithAsyncMetadata.clear();const flatResolvedDeps=(yield Promise.all(promises)).flat(2);_this2.queueTypesFromModulesArray(flatResolvedDeps);for(const component of flatResolvedDeps)_this2.applyProviderOverridesInScope(component)}))()}compileComponents(){var _this3=this;return(0,asyncToGenerator.A)((function*(){if(_this3.clearComponentResolutionQueue(),yield _this3.resolvePendingComponentsWithAsyncMetadata(),assertNoStandaloneComponents(_this3.declarations,_this3.resolvers.component,'"TestBed.configureTestingModule" call'),_this3.compileTypesSync()){let resourceLoader,resolver=url=>(resourceLoader||(resourceLoader=_this3.injector.get(compiler.ResourceLoader)),Promise.resolve(resourceLoader.get(url)));yield(0,core["ɵresolveComponentResources"])(resolver)}}))()}finalize(){this.compileTypesSync(),this.compileTestModule(),this.applyTransitiveScopes(),this.applyProviderOverrides(),this.patchComponentsWithExistingStyles(),this.componentToModuleScope.clear();const parentInjector=this.platform.injector;this.testModuleRef=new core["ɵRender3NgModuleRef"](this.testModuleType,parentInjector,[]),this.testModuleRef.injector.get(core.ApplicationInitStatus).runInitializers();const localeId=this.testModuleRef.injector.get(core.LOCALE_ID,core["ɵDEFAULT_LOCALE_ID"]);return(0,core["ɵsetLocaleId"])(localeId),this.testModuleRef}_compileNgModuleSync(moduleType){this.queueTypesFromModulesArray([moduleType]),this.compileTypesSync(),this.applyProviderOverrides(),this.applyProviderOverridesInScope(moduleType),this.applyTransitiveScopes()}_compileNgModuleAsync(moduleType){var _this4=this;return(0,asyncToGenerator.A)((function*(){_this4.queueTypesFromModulesArray([moduleType]),yield _this4.compileComponents(),_this4.applyProviderOverrides(),_this4.applyProviderOverridesInScope(moduleType),_this4.applyTransitiveScopes()}))()}_getModuleResolver(){return this.resolvers.module}_getComponentFactories(moduleType){return maybeUnwrapFn(moduleType.ɵmod.declarations).reduce(((factories,declaration)=>{const componentDef=declaration.ɵcmp;return componentDef&&factories.push(new core["ɵRender3ComponentFactory"](componentDef,this.testModuleRef)),factories}),[])}compileTypesSync(){let needsAsyncResources=!1;return this.pendingComponents.forEach((declaration=>{if((0,core["ɵgetAsyncClassMetadataFn"])(declaration))throw new Error(`Component '${declaration.name}' has unresolved metadata. Please call \`await TestBed.compileComponents()\` before running this test.`);needsAsyncResources=needsAsyncResources||(0,core["ɵisComponentDefPendingResolution"])(declaration);const metadata=this.resolvers.component.resolve(declaration);if(null===metadata)throw invalidTypeError(declaration.name,"Component");this.maybeStoreNgDef(core["ɵNG_COMP_DEF"],declaration),core["ɵUSE_RUNTIME_DEPS_TRACKER_FOR_JIT"]&&core["ɵdepsTracker"].clearScopeCacheFor(declaration),(0,core["ɵcompileComponent"])(declaration,metadata)})),this.pendingComponents.clear(),this.pendingDirectives.forEach((declaration=>{const metadata=this.resolvers.directive.resolve(declaration);if(null===metadata)throw invalidTypeError(declaration.name,"Directive");this.maybeStoreNgDef(core["ɵNG_DIR_DEF"],declaration),(0,core["ɵcompileDirective"])(declaration,metadata)})),this.pendingDirectives.clear(),this.pendingPipes.forEach((declaration=>{const metadata=this.resolvers.pipe.resolve(declaration);if(null===metadata)throw invalidTypeError(declaration.name,"Pipe");this.maybeStoreNgDef(core["ɵNG_PIPE_DEF"],declaration),(0,core["ɵcompilePipe"])(declaration,metadata)})),this.pendingPipes.clear(),needsAsyncResources}applyTransitiveScopes(){if(this.overriddenModules.size>0){const testingModuleDef=this.testModuleType[core["ɵNG_MOD_DEF"]],affectedModules=this.collectModulesAffectedByOverrides(testingModuleDef.imports);affectedModules.size>0&&affectedModules.forEach((moduleType=>{core["ɵUSE_RUNTIME_DEPS_TRACKER_FOR_JIT"]?core["ɵdepsTracker"].clearScopeCacheFor(moduleType):(this.storeFieldOfDefOnType(moduleType,core["ɵNG_MOD_DEF"],"transitiveCompileScopes"),moduleType[core["ɵNG_MOD_DEF"]].transitiveCompileScopes=null)}))}const moduleToScope=new Map,getScopeOfModule=moduleType=>{if(!moduleToScope.has(moduleType)){const realType=function isTestingModuleOverride(value){return value===TestingModuleOverride.DECLARATION||value===TestingModuleOverride.OVERRIDE_TEMPLATE}(moduleType)?this.testModuleType:moduleType;moduleToScope.set(moduleType,(0,core["ɵtransitiveScopesFor"])(realType))}return moduleToScope.get(moduleType)};this.componentToModuleScope.forEach(((moduleType,componentType)=>{if(null!==moduleType){const moduleScope=getScopeOfModule(moduleType);this.storeFieldOfDefOnType(componentType,core["ɵNG_COMP_DEF"],"directiveDefs"),this.storeFieldOfDefOnType(componentType,core["ɵNG_COMP_DEF"],"pipeDefs"),(0,core["ɵpatchComponentDefWithScope"])(getComponentDef(componentType),moduleScope)}this.storeFieldOfDefOnType(componentType,core["ɵNG_COMP_DEF"],"tView")})),this.componentToModuleScope.clear()}applyProviderOverrides(){const maybeApplyOverrides=field=>type=>{const metadata=(field===core["ɵNG_COMP_DEF"]?this.resolvers.component:this.resolvers.directive).resolve(type);this.hasProviderOverrides(metadata.providers)&&this.patchDefWithProviderOverrides(type,field)};this.seenComponents.forEach(maybeApplyOverrides(core["ɵNG_COMP_DEF"])),this.seenDirectives.forEach(maybeApplyOverrides(core["ɵNG_DIR_DEF"])),this.seenComponents.clear(),this.seenDirectives.clear()}applyProviderOverridesInScope(type){if(!(isStandaloneComponent(type)||function isNgModule(value){return hasNgModuleDef(value)}(type))||this.scopesWithOverriddenProviders.has(type))return;this.scopesWithOverriddenProviders.add(type);const injectorDef=type[core["ɵNG_INJ_DEF"]];if(0!==this.providerOverridesByToken.size)if(isStandaloneComponent(type)){const dependencies=maybeUnwrapFn(getComponentDef(type).dependencies??[]);for(const dependency of dependencies)this.applyProviderOverridesInScope(dependency)}else{const providers=[...injectorDef.providers,...this.providerOverridesByModule.get(type)||[]];this.hasProviderOverrides(providers)&&(this.maybeStoreNgDef(core["ɵNG_INJ_DEF"],type),this.storeFieldOfDefOnType(type,core["ɵNG_INJ_DEF"],"providers"),injectorDef.providers=this.getOverriddenProviders(providers));const imports=maybeUnwrapFn(type[core["ɵNG_MOD_DEF"]].imports);for(const importedModule of imports)this.applyProviderOverridesInScope(importedModule);for(const importedModule of flatten(injectorDef.imports))isModuleWithProviders(importedModule)&&(this.defCleanupOps.push({object:importedModule,fieldName:"providers",originalValue:importedModule.providers}),importedModule.providers=this.getOverriddenProviders(importedModule.providers))}}patchComponentsWithExistingStyles(){this.existingComponentStyles.forEach(((styles,type)=>type[core["ɵNG_COMP_DEF"]].styles=styles)),this.existingComponentStyles.clear()}queueTypeArray(arr,moduleType){for(const value of arr)Array.isArray(value)?this.queueTypeArray(value,moduleType):this.queueType(value,moduleType)}recompileNgModule(ngModule,metadata){this.maybeStoreNgDef(core["ɵNG_MOD_DEF"],ngModule),this.maybeStoreNgDef(core["ɵNG_INJ_DEF"],ngModule),(0,core["ɵcompileNgModuleDefs"])(ngModule,metadata)}maybeRegisterComponentWithAsyncMetadata(type){(0,core["ɵgetAsyncClassMetadataFn"])(type)&&this.componentsWithAsyncMetadata.add(type)}queueType(type,moduleType){this.maybeRegisterComponentWithAsyncMetadata(type);if(this.resolvers.component.resolve(type))return!(0,core["ɵisComponentDefPendingResolution"])(type)&&type.hasOwnProperty(core["ɵNG_COMP_DEF"])||this.pendingComponents.add(type),this.seenComponents.add(type),void(this.componentToModuleScope.has(type)&&this.componentToModuleScope.get(type)!==TestingModuleOverride.DECLARATION||this.componentToModuleScope.set(type,moduleType));if(this.resolvers.directive.resolve(type))return type.hasOwnProperty(core["ɵNG_DIR_DEF"])||this.pendingDirectives.add(type),void this.seenDirectives.add(type);!this.resolvers.pipe.resolve(type)||type.hasOwnProperty(core["ɵNG_PIPE_DEF"])||this.pendingPipes.add(type)}queueTypesFromModulesArray(arr){const processedDefs=new Set,queueTypesFromModulesArrayRecur=arr=>{for(const value of arr)if(Array.isArray(value))queueTypesFromModulesArrayRecur(value);else if(hasNgModuleDef(value)){const def=value.ɵmod;if(processedDefs.has(def))continue;processedDefs.add(def),this.queueTypeArray(maybeUnwrapFn(def.declarations),value),queueTypesFromModulesArrayRecur(maybeUnwrapFn(def.imports)),queueTypesFromModulesArrayRecur(maybeUnwrapFn(def.exports))}else if(isModuleWithProviders(value))queueTypesFromModulesArrayRecur([value.ngModule]);else if(isStandaloneComponent(value)){this.queueType(value,null);const def=getComponentDef(value);if(processedDefs.has(def))continue;processedDefs.add(def);maybeUnwrapFn(def.dependencies??[]).forEach((dependency=>{isStandaloneComponent(dependency)||hasNgModuleDef(dependency)?queueTypesFromModulesArrayRecur([dependency]):this.queueType(dependency,null)}))}};queueTypesFromModulesArrayRecur(arr)}collectModulesAffectedByOverrides(arr){const seenModules=new Set,affectedModules=new Set,calcAffectedModulesRecur=(arr,path)=>{for(const value of arr)if(Array.isArray(value))calcAffectedModulesRecur(value,path);else if(hasNgModuleDef(value)){if(seenModules.has(value)){affectedModules.has(value)&&path.forEach((item=>affectedModules.add(item)));continue}seenModules.add(value),this.overriddenModules.has(value)&&path.forEach((item=>affectedModules.add(item)));const moduleDef=value[core["ɵNG_MOD_DEF"]];calcAffectedModulesRecur(maybeUnwrapFn(moduleDef.imports),path.concat(value))}};return calcAffectedModulesRecur(arr,[]),affectedModules}maybeStoreNgDef(prop,type){this.initialNgDefs.has(type)||this.initialNgDefs.set(type,new Map);const currentDefs=this.initialNgDefs.get(type);if(!currentDefs.has(prop)){const currentDef=Object.getOwnPropertyDescriptor(type,prop);currentDefs.set(prop,currentDef)}}storeFieldOfDefOnType(type,defField,fieldName){const def=type[defField],originalValue=def[fieldName];this.defCleanupOps.push({object:def,fieldName,originalValue})}clearComponentResolutionQueue(){null===this.originalComponentResolutionQueue&&(this.originalComponentResolutionQueue=new Map),(0,core["ɵclearResolutionOfComponentResourcesQueue"])().forEach(((value,key)=>this.originalComponentResolutionQueue.set(key,value)))}restoreComponentResolutionQueue(){null!==this.originalComponentResolutionQueue&&((0,core["ɵrestoreComponentResolutionQueue"])(this.originalComponentResolutionQueue),this.originalComponentResolutionQueue=null)}restoreOriginalState(){forEachRight(this.defCleanupOps,(op=>{op.object[op.fieldName]=op.originalValue})),this.initialNgDefs.forEach(((defs,type)=>{core["ɵUSE_RUNTIME_DEPS_TRACKER_FOR_JIT"]&&core["ɵdepsTracker"].clearScopeCacheFor(type),defs.forEach(((descriptor,prop)=>{descriptor?Object.defineProperty(type,prop,descriptor):delete type[prop]}))})),this.initialNgDefs.clear(),this.scopesWithOverriddenProviders.clear(),this.restoreComponentResolutionQueue(),(0,core["ɵsetLocaleId"])(core["ɵDEFAULT_LOCALE_ID"])}compileTestModule(){class RootScopeModule{}(0,core["ɵcompileNgModuleDefs"])(RootScopeModule,{providers:[...this.rootProviderOverrides,(0,core["ɵinternalProvideZoneChangeDetection"])({}),TestBedApplicationErrorHandler,{provide:core["ɵINTERNAL_APPLICATION_ERROR_HANDLER"],useFactory:()=>{if((0,core.inject)(core["ɵZONELESS_ENABLED"])||(0,core.inject)(RETHROW_APPLICATION_ERRORS,{optional:!0})){const handler=(0,core.inject)(TestBedApplicationErrorHandler);return e=>{handler.handleError(e)}}{const userErrorHandler=(0,core.inject)(core.ErrorHandler),ngZone=(0,core.inject)(core.NgZone);return e=>ngZone.runOutsideAngular((()=>userErrorHandler.handleError(e)))}}},{provide:core["ɵChangeDetectionScheduler"],useExisting:core["ɵChangeDetectionSchedulerImpl"]}]});const providers=[{provide:core.Compiler,useFactory:()=>new R3TestCompiler(this)},{provide:core["ɵDEFER_BLOCK_CONFIG"],useValue:{behavior:this.deferBlockBehavior}},...this.providers,...this.providerOverrides],imports=[RootScopeModule,this.additionalModuleTypes,this.imports||[]];(0,core["ɵcompileNgModuleDefs"])(this.testModuleType,{declarations:this.declarations,imports,schemas:this.schemas,providers},!0),this.applyProviderOverridesInScope(this.testModuleType)}get injector(){if(null!==this._injector)return this._injector;const providers=[];return this.platform.injector.get(core.COMPILER_OPTIONS).forEach((opts=>{opts.providers&&providers.push(opts.providers)})),null!==this.compilerProviders&&providers.push(...this.compilerProviders),this._injector=core.Injector.create({providers,parent:this.platform.injector}),this._injector}getSingleProviderOverrides(provider){const token=getProviderToken(provider);return this.providerOverridesByToken.get(token)||null}getProviderOverrides(providers){return providers&&providers.length&&0!==this.providerOverridesByToken.size?flatten(flattenProviders(providers,(provider=>this.getSingleProviderOverrides(provider)||[]))):[]}getOverriddenProviders(providers){if(!providers||!providers.length||0===this.providerOverridesByToken.size)return[];const flattenedProviders=flattenProviders(providers),overrides=this.getProviderOverrides(flattenedProviders),overriddenProviders=[...flattenedProviders,...overrides],final=[],seenOverriddenProviders=new Set;return forEachRight(overriddenProviders,(provider=>{const token=getProviderToken(provider);this.providerOverridesByToken.has(token)?seenOverriddenProviders.has(token)||(seenOverriddenProviders.add(token),final.unshift({...provider,multi:!1})):final.unshift(provider)})),final}hasProviderOverrides(providers){return this.getProviderOverrides(providers).length>0}patchDefWithProviderOverrides(declaration,field){const def=declaration[field];if(def&&def.providersResolver){this.maybeStoreNgDef(field,declaration);const resolver=def.providersResolver,processProvidersFn=providers=>this.getOverriddenProviders(providers);this.storeFieldOfDefOnType(declaration,field,"providersResolver"),def.providersResolver=ngDef=>resolver(ngDef,processProvidersFn)}}}function isStandaloneComponent(value){const def=getComponentDef(value);return!!def?.standalone}function getComponentDef(value){return value.ɵcmp??null}function hasNgModuleDef(value){return value.hasOwnProperty("ɵmod")}function maybeUnwrapFn(maybeFn){return maybeFn instanceof Function?maybeFn():maybeFn}function flatten(values){const out=[];return values.forEach((value=>{Array.isArray(value)?out.push(...flatten(value)):out.push(value)})),out}function identityFn(value){return value}function flattenProviders(providers,mapFn=identityFn){const out=[];for(let provider of providers)(0,core["ɵisEnvironmentProviders"])(provider)&&(provider=provider.ɵproviders),Array.isArray(provider)?out.push(...flattenProviders(provider,mapFn)):out.push(mapFn(provider));return out}function getProviderToken(provider){return function getProviderField(provider,field){return provider&&"object"==typeof provider&&provider[field]}(provider,"provide")||provider}function isModuleWithProviders(value){return value.hasOwnProperty("ngModule")}function forEachRight(values,fn){for(let idx=values.length-1;idx>=0;idx--)fn(values[idx],idx)}function invalidTypeError(name,expectedType){return new Error(`${name} class doesn't have @${expectedType} decorator or is missing metadata.`)}class R3TestCompiler{constructor(testBed){this.testBed=testBed}compileModuleSync(moduleType){return this.testBed._compileNgModuleSync(moduleType),new core["ɵNgModuleFactory"](moduleType)}compileModuleAsync(moduleType){var _this5=this;return(0,asyncToGenerator.A)((function*(){return yield _this5.testBed._compileNgModuleAsync(moduleType),new core["ɵNgModuleFactory"](moduleType)}))()}compileModuleAndAllComponentsSync(moduleType){const ngModuleFactory=this.compileModuleSync(moduleType),componentFactories=this.testBed._getComponentFactories(moduleType);return new core.ModuleWithComponentFactories(ngModuleFactory,componentFactories)}compileModuleAndAllComponentsAsync(moduleType){var _this6=this;return(0,asyncToGenerator.A)((function*(){const ngModuleFactory=yield _this6.compileModuleAsync(moduleType),componentFactories=_this6.testBed._getComponentFactories(moduleType);return new core.ModuleWithComponentFactories(ngModuleFactory,componentFactories)}))()}clearCache(){}clearCacheFor(type){}getModuleId(moduleType){const meta=this.testBed._getModuleResolver().resolve(moduleType);return meta&&meta.id||void 0}}let _nextRootElementId=0;class TestBedImpl{constructor(){this._instanceDeferBlockBehavior=DEFER_BLOCK_DEFAULT_BEHAVIOR,this.platform=null,this.ngModule=null,this._compiler=null,this._testModuleRef=null,this._activeFixtures=[],this.globalCompilationChecked=!1}static{this._INSTANCE=null}static get INSTANCE(){return TestBedImpl._INSTANCE=TestBedImpl._INSTANCE||new TestBedImpl}static initTestEnvironment(ngModule,platform,options){const testBed=TestBedImpl.INSTANCE;return testBed.initTestEnvironment(ngModule,platform,options),testBed}static resetTestEnvironment(){TestBedImpl.INSTANCE.resetTestEnvironment()}static configureCompiler(config){return TestBedImpl.INSTANCE.configureCompiler(config)}static configureTestingModule(moduleDef){return TestBedImpl.INSTANCE.configureTestingModule(moduleDef)}static compileComponents(){return TestBedImpl.INSTANCE.compileComponents()}static overrideModule(ngModule,override){return TestBedImpl.INSTANCE.overrideModule(ngModule,override)}static overrideComponent(component,override){return TestBedImpl.INSTANCE.overrideComponent(component,override)}static overrideDirective(directive,override){return TestBedImpl.INSTANCE.overrideDirective(directive,override)}static overridePipe(pipe,override){return TestBedImpl.INSTANCE.overridePipe(pipe,override)}static overrideTemplate(component,template){return TestBedImpl.INSTANCE.overrideTemplate(component,template)}static overrideTemplateUsingTestingModule(component,template){return TestBedImpl.INSTANCE.overrideTemplateUsingTestingModule(component,template)}static overrideProvider(token,provider){return TestBedImpl.INSTANCE.overrideProvider(token,provider)}static inject(token,notFoundValue,flags){return TestBedImpl.INSTANCE.inject(token,notFoundValue,(0,core["ɵconvertToBitFlags"])(flags))}static get(token,notFoundValue=core.Injector.THROW_IF_NOT_FOUND,flags=core.InjectFlags.Default){return TestBedImpl.INSTANCE.inject(token,notFoundValue,flags)}static runInInjectionContext(fn){return TestBedImpl.INSTANCE.runInInjectionContext(fn)}static createComponent(component){return TestBedImpl.INSTANCE.createComponent(component)}static resetTestingModule(){return TestBedImpl.INSTANCE.resetTestingModule()}static execute(tokens,fn,context){return TestBedImpl.INSTANCE.execute(tokens,fn,context)}static get platform(){return TestBedImpl.INSTANCE.platform}static get ngModule(){return TestBedImpl.INSTANCE.ngModule}static flushEffects(){return TestBedImpl.INSTANCE.flushEffects()}initTestEnvironment(ngModule,platform,options){if(this.platform||this.ngModule)throw new Error("Cannot set base providers because it has already been called");TestBedImpl._environmentTeardownOptions=options?.teardown,TestBedImpl._environmentErrorOnUnknownElementsOption=options?.errorOnUnknownElements,TestBedImpl._environmentErrorOnUnknownPropertiesOption=options?.errorOnUnknownProperties,this.platform=platform,this.ngModule=ngModule,this._compiler=new TestBedCompiler(this.platform,this.ngModule),(0,core["ɵsetAllowDuplicateNgModuleIdsForTest"])(!0)}resetTestEnvironment(){this.resetTestingModule(),this._compiler=null,this.platform=null,this.ngModule=null,TestBedImpl._environmentTeardownOptions=void 0,(0,core["ɵsetAllowDuplicateNgModuleIdsForTest"])(!1)}resetTestingModule(){this.checkGlobalCompilationFinished(),(0,core["ɵresetCompiledComponents"])(),null!==this._compiler&&this.compiler.restoreOriginalState(),this._compiler=new TestBedCompiler(this.platform,this.ngModule),(0,core["ɵsetUnknownElementStrictMode"])(this._previousErrorOnUnknownElementsOption??false),(0,core["ɵsetUnknownPropertyStrictMode"])(this._previousErrorOnUnknownPropertiesOption??false);try{this.destroyActiveFixtures()}finally{try{this.shouldTearDownTestingModule()&&this.tearDownTestingModule()}finally{this._testModuleRef=null,this._instanceTeardownOptions=void 0,this._instanceErrorOnUnknownElementsOption=void 0,this._instanceErrorOnUnknownPropertiesOption=void 0,this._instanceDeferBlockBehavior=DEFER_BLOCK_DEFAULT_BEHAVIOR}}return this}configureCompiler(config){if(null!=config.useJit)throw new Error("JIT compiler is not configurable via TestBed APIs.");return void 0!==config.providers&&this.compiler.setCompilerProviders(config.providers),this}configureTestingModule(moduleDef){return this.assertNotInstantiated("TestBed.configureTestingModule","configure the test module"),this.checkGlobalCompilationFinished(),this._instanceTeardownOptions=moduleDef.teardown,this._instanceErrorOnUnknownElementsOption=moduleDef.errorOnUnknownElements,this._instanceErrorOnUnknownPropertiesOption=moduleDef.errorOnUnknownProperties,this._instanceDeferBlockBehavior=moduleDef.deferBlockBehavior??DEFER_BLOCK_DEFAULT_BEHAVIOR,this._previousErrorOnUnknownElementsOption=(0,core["ɵgetUnknownElementStrictMode"])(),(0,core["ɵsetUnknownElementStrictMode"])(this.shouldThrowErrorOnUnknownElements()),this._previousErrorOnUnknownPropertiesOption=(0,core["ɵgetUnknownPropertyStrictMode"])(),(0,core["ɵsetUnknownPropertyStrictMode"])(this.shouldThrowErrorOnUnknownProperties()),this.compiler.configureTestingModule(moduleDef),this}compileComponents(){return this.compiler.compileComponents()}inject(token,notFoundValue,flags){if(token===TestBed)return this;const UNDEFINED={},result=this.testModuleRef.injector.get(token,UNDEFINED,(0,core["ɵconvertToBitFlags"])(flags));return result===UNDEFINED?this.compiler.injector.get(token,notFoundValue,flags):result}get(token,notFoundValue=core.Injector.THROW_IF_NOT_FOUND,flags=core.InjectFlags.Default){return this.inject(token,notFoundValue,flags)}runInInjectionContext(fn){return(0,core.runInInjectionContext)(this.inject(core.EnvironmentInjector),fn)}execute(tokens,fn,context){const params=tokens.map((t=>this.inject(t)));return fn.apply(context,params)}overrideModule(ngModule,override){return this.assertNotInstantiated("overrideModule","override module metadata"),this.compiler.overrideModule(ngModule,override),this}overrideComponent(component,override){return this.assertNotInstantiated("overrideComponent","override component metadata"),this.compiler.overrideComponent(component,override),this}overrideTemplateUsingTestingModule(component,template){return this.assertNotInstantiated("TestBed.overrideTemplateUsingTestingModule","Cannot override template when the test module has already been instantiated"),this.compiler.overrideTemplateUsingTestingModule(component,template),this}overrideDirective(directive,override){return this.assertNotInstantiated("overrideDirective","override directive metadata"),this.compiler.overrideDirective(directive,override),this}overridePipe(pipe,override){return this.assertNotInstantiated("overridePipe","override pipe metadata"),this.compiler.overridePipe(pipe,override),this}overrideProvider(token,provider){return this.assertNotInstantiated("overrideProvider","override provider"),this.compiler.overrideProvider(token,provider),this}overrideTemplate(component,template){return this.overrideComponent(component,{set:{template,templateUrl:null}})}createComponent(type){const testComponentRenderer=this.inject(TestComponentRenderer),rootElId="root"+_nextRootElementId++;if(testComponentRenderer.insertRootElement(rootElId),(0,core["ɵgetAsyncClassMetadataFn"])(type))throw new Error(`Component '${type.name}' has unresolved metadata. Please call \`await TestBed.compileComponents()\` before running this test.`);const componentDef=type.ɵcmp;if(!componentDef)throw new Error(`It looks like '${(0,core["ɵstringify"])(type)}' has not been compiled.`);const componentFactory=new core["ɵRender3ComponentFactory"](componentDef),initComponent=()=>{const componentRef=componentFactory.create(core.Injector.NULL,[],`#${rootElId}`,this.testModuleRef);return this.runInInjectionContext((()=>{const fixture=this.inject(core["ɵZONELESS_ENABLED"])?new ScheduledComponentFixture(componentRef):new PseudoApplicationComponentFixture(componentRef);return fixture.initialize(),fixture}))},ngZone=this.inject(ComponentFixtureNoNgZone,!1)?null:this.inject(core.NgZone,null),fixture=ngZone?ngZone.run(initComponent):initComponent();return this._activeFixtures.push(fixture),fixture}get compiler(){if(null===this._compiler)throw new Error("Need to call TestBed.initTestEnvironment() first");return this._compiler}get testModuleRef(){return null===this._testModuleRef&&(this._testModuleRef=this.compiler.finalize()),this._testModuleRef}assertNotInstantiated(methodName,methodDescription){if(null!==this._testModuleRef)throw new Error(`Cannot ${methodDescription} when the test module has already been instantiated. Make sure you are not using \`inject\` before \`${methodName}\`.`)}checkGlobalCompilationFinished(){this.globalCompilationChecked||null!==this._testModuleRef||(0,core["ɵflushModuleScopingQueueAsMuchAsPossible"])(),this.globalCompilationChecked=!0}destroyActiveFixtures(){let errorCount=0;if(this._activeFixtures.forEach((fixture=>{try{fixture.destroy()}catch(e){errorCount++,console.error("Error during cleanup of component",{component:fixture.componentInstance,stacktrace:e})}})),this._activeFixtures=[],errorCount>0&&this.shouldRethrowTeardownErrors())throw Error(`${errorCount} ${1===errorCount?"component":"components"} threw errors during cleanup`)}shouldRethrowTeardownErrors(){const instanceOptions=this._instanceTeardownOptions,environmentOptions=TestBedImpl._environmentTeardownOptions;return!instanceOptions&&!environmentOptions||(instanceOptions?.rethrowErrors??environmentOptions?.rethrowErrors??this.shouldTearDownTestingModule())}shouldThrowErrorOnUnknownElements(){return this._instanceErrorOnUnknownElementsOption??TestBedImpl._environmentErrorOnUnknownElementsOption??false}shouldThrowErrorOnUnknownProperties(){return this._instanceErrorOnUnknownPropertiesOption??TestBedImpl._environmentErrorOnUnknownPropertiesOption??false}shouldTearDownTestingModule(){return this._instanceTeardownOptions?.destroyAfterEach??TestBedImpl._environmentTeardownOptions?.destroyAfterEach??true}getDeferBlockBehavior(){return this._instanceDeferBlockBehavior}tearDownTestingModule(){if(null===this._testModuleRef)return;const testRenderer=this.inject(TestComponentRenderer);try{this._testModuleRef.destroy()}catch(e){if(this.shouldRethrowTeardownErrors())throw e;console.error("Error during cleanup of a testing module",{component:this._testModuleRef.instance,stacktrace:e})}finally{testRenderer.removeAllRootElements?.()}}flushEffects(){this.inject(core["ɵEffectScheduler"]).flush()}}const TestBed=TestBedImpl;function getCleanupHook(expectedTeardownValue){return()=>{const testBed=TestBedImpl.INSTANCE;testBed.shouldTearDownTestingModule()===expectedTeardownValue&&(testBed.resetTestingModule(),function resetFakeAsyncZoneIfExists(){fakeAsyncTestModule&&fakeAsyncTestModule.resetFakeAsyncZone()}())}}globalThis.beforeEach?.(getCleanupHook(!1)),globalThis.afterEach?.(getCleanupHook(!0));class RouterTestingModule{static withRoutes(routes,config){return{ngModule:RouterTestingModule,providers:[{provide:fesm2022_router.bw,multi:!0,useValue:routes},{provide:fesm2022_router.J_,useValue:config||{}}]}}static{this.ɵfac=function RouterTestingModule_Factory(__ngFactoryType__){return new(__ngFactoryType__||RouterTestingModule)}}static{this.ɵmod=core["ɵɵdefineNgModule"]({type:RouterTestingModule,exports:[fesm2022_router.iI]})}static{this.ɵinj=core["ɵɵdefineInjector"]({providers:[fesm2022_router.uc,provideLocationMocks(),(0,fesm2022_router.Sn)(fesm2022_router.D7).ɵproviders,{provide:fesm2022_router.bw,multi:!0,useValue:[]}],imports:[fesm2022_router.iI]})}}("undefined"==typeof ngDevMode||ngDevMode)&&core["ɵsetClassMetadata"](RouterTestingModule,[{type:core.NgModule,args:[{exports:[fesm2022_router.iI],providers:[fesm2022_router.uc,provideLocationMocks(),(0,fesm2022_router.Sn)(fesm2022_router.D7).ɵproviders,{provide:fesm2022_router.bw,multi:!0,useValue:[]}]}]}],null,null);class RootFixtureService{createHarness(){if(this.harness)throw new Error("Only one harness should be created per test.");return this.harness=new RouterTestingHarness(this.getRootFixture()),this.harness}getRootFixture(){return void 0!==this.fixture||(this.fixture=TestBed.createComponent(RootCmp),this.fixture.detectChanges()),this.fixture}static{this.ɵfac=function RootFixtureService_Factory(__ngFactoryType__){return new(__ngFactoryType__||RootFixtureService)}}static{this.ɵprov=core["ɵɵdefineInjectable"]({token:RootFixtureService,factory:RootFixtureService.ɵfac,providedIn:"root"})}}("undefined"==typeof ngDevMode||ngDevMode)&&core["ɵsetClassMetadata"](RootFixtureService,[{type:core.Injectable,args:[{providedIn:"root"}]}],null,null);class RootCmp{static{this.ɵfac=function RootCmp_Factory(__ngFactoryType__){return new(__ngFactoryType__||RootCmp)}}static{this.ɵcmp=core["ɵɵdefineComponent"]({type:RootCmp,selectors:[["ng-component"]],viewQuery:function RootCmp_Query(rf,ctx){if(1&rf&&core["ɵɵviewQuery"](fesm2022_router.n3,5),2&rf){let _t;core["ɵɵqueryRefresh"](_t=core["ɵɵloadQuery"]())&&(ctx.outlet=_t.first)}},standalone:!0,features:[core["ɵɵStandaloneFeature"]],decls:1,vars:0,template:function RootCmp_Template(rf,ctx){1&rf&&core["ɵɵelement"](0,"router-outlet")},dependencies:[fesm2022_router.n3],encapsulation:2})}}("undefined"==typeof ngDevMode||ngDevMode)&&core["ɵsetClassMetadata"](RootCmp,[{type:core.Component,args:[{standalone:!0,template:"<router-outlet></router-outlet>",imports:[fesm2022_router.n3]}]}],null,{outlet:[{type:core.ViewChild,args:[fesm2022_router.n3]}]});class RouterTestingHarness{static create(initialUrl){return(0,asyncToGenerator.A)((function*(){const harness=TestBed.inject(RootFixtureService).createHarness();return void 0!==initialUrl&&(yield harness.navigateByUrl(initialUrl)),harness}))()}constructor(fixture){this.fixture=fixture}detectChanges(){this.fixture.detectChanges()}get routeDebugElement(){const outlet=this.fixture.componentInstance.outlet;return outlet&&outlet.isActivated?this.fixture.debugElement.query((v=>v.componentInstance===outlet.component)):null}get routeNativeElement(){return this.routeDebugElement?.nativeElement??null}navigateByUrl(url,requiredRoutedComponentType){var _this=this;return(0,asyncToGenerator.A)((function*(){const router=TestBed.inject(fesm2022_router.Ix);let resolveFn;const redirectTrackingPromise=new Promise((resolve=>{resolveFn=resolve}));(0,fesm2022_router.JS)(TestBed.inject(fesm2022_router.Ix),resolveFn),yield router.navigateByUrl(url),yield redirectTrackingPromise,_this.fixture.detectChanges();const outlet=_this.fixture.componentInstance.outlet;if(outlet&&outlet.isActivated&&outlet.activatedRoute.component){const activatedComponent=outlet.component;if(void 0!==requiredRoutedComponentType&&!(activatedComponent instanceof requiredRoutedComponentType))throw new Error(`Unexpected routed component type. Expected ${requiredRoutedComponentType.name} but got ${activatedComponent.constructor.name}`);return activatedComponent}if(void 0!==requiredRoutedComponentType)throw new Error(`Unexpected routed component type. Expected ${requiredRoutedComponentType.name} but the navigation did not activate any component.`);return null}))()}}}}]);