{"version":3,"file":"src-lib-filter-chips-filter-chips-stories.05020d6c.iframe.bundle.js","mappings":";;;;;;;;AAcA;;AAiBA;AACA;AACA;;AAEA;;AAEA;;;AAGA;;;;AAKA;;;;;;;;;;;;;;AC3BA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACEA;AAoDA;;AAEA;AACA;;;AAGA;AACA;;;AAIA","sources":["webpack://green/./dist/libs/core/src/components/filter-chips/filter-chip/filter-chip.component.js","webpack://green/./dist/libs/core/src/components/icon/icon.component.js","webpack://green/./dist/libs/core/src/components/filter-chips/filter-chips.component.js"],"sourcesContent":["import {\n  __decorateClass\n} from \"../../../chunks/chunk.QU3DSPNU.js\";\nimport { property } from \"lit/decorators.js\";\nimport { classMap } from \"lit/directives/class-map.js\";\nimport { GdsElement } from \"../../../gds-element.js\";\nimport { TransitionalStyles } from \"../../../transitional-styles.js\";\nimport {\n  gdsCustomElement,\n  html\n} from \"../../../utils/helpers/custom-element-scoping.js\";\nimport { GdsButton } from \"../../button/button.component.js\";\nimport { IconCheckmark } from \"../../icon/icons/checkmark.component.js\";\nimport { styles } from \"./filter-chip.styles.js\";\nlet GdsFilterChip = class extends GdsElement {\n  constructor() {\n    super(...arguments);\n    this.selected = false;\n    this.size = \"large\";\n  }\n  connectedCallback() {\n    super.connectedCallback();\n    this.setAttribute(\"role\", \"none\");\n    TransitionalStyles.instance.apply(this, \"gds-filter-chip\");\n  }\n  render() {\n    const btnClasses = {\n      \"btn-p\": !this.selected\n    };\n    return html`<gds-button\n      class=\"btn\"\n      .size=${this.size === \"large\" ? \"medium\" : \"small\"}\n      .rank=${this.selected ? \"primary\" : \"secondary\"}\n      variant=${this._isUsingTransitionalStyles ? \"ghost\" : \"default\"}\n      gds-role=\"option\"\n      gds-aria-selected=${this.selected}\n    >\n      <span class=${classMap(btnClasses)}><slot></slot></span>\n      <gds-icon-checkmark\n        slot=\"trail\"\n        style=\"display: ${this.selected ? \"contents\" : \"none\"}\"\n        size=\"1rem\"\n        class=\"icon\"\n      ></gds-icon-checkmark>\n    </gds-button>`;\n  }\n};\nGdsFilterChip.styles = [styles];\n__decorateClass([\n  property({ reflect: true, type: Boolean })\n], GdsFilterChip.prototype, \"selected\", 2);\n__decorateClass([\n  property()\n], GdsFilterChip.prototype, \"value\", 2);\n__decorateClass([\n  property({ reflect: true, type: String })\n], GdsFilterChip.prototype, \"size\", 2);\nGdsFilterChip = __decorateClass([\n  gdsCustomElement(\"gds-filter-chip\", {\n    dependsOn: [GdsButton, IconCheckmark]\n  })\n], GdsFilterChip);\nexport {\n  GdsFilterChip\n};\n","import {\n  __decorateClass\n} from \"../../chunks/chunk.QU3DSPNU.js\";\nimport { html } from \"lit\";\nimport { property } from \"lit/decorators.js\";\nimport { unsafeHTML } from \"lit/directives/unsafe-html.js\";\nimport { GdsElement } from \"../../gds-element.js\";\nimport { tokens } from \"../../tokens.style.js\";\nimport { styleExpressionProperty } from \"../../utils/decorators/style-expression-property.js\";\nimport {\n  forColorTokens,\n  forSpaceTokensAndCustomValues\n} from \"../../utils/helpers/index.js\";\nimport {\n  withLayoutChildProps,\n  withMarginProps\n} from \"../../utils/mixins/declarative-layout-mixins.js\";\nimport IconStyles from \"./icon.styles.js\";\nclass GdsIcon extends withMarginProps(withLayoutChildProps(GdsElement)) {\n  constructor() {\n    super(...arguments);\n    this.solid = false;\n    this.level = \"2\";\n    this.label = \"\";\n  }\n  /**\n   * Generates the SVG attributes for the icon\n   * @private\n   */\n  get svgAttributes() {\n    const constructor = this.constructor;\n    const baseAttrs = {\n      fill: \"none\",\n      xmlns: \"http://www.w3.org/2000/svg\",\n      viewBox: constructor._viewBox,\n      part: \"icon\"\n    };\n    if (this.label) {\n      return {\n        ...baseAttrs,\n        \"aria-label\": this.label\n      };\n    } else {\n      return {\n        ...baseAttrs,\n        role: \"presentation\"\n      };\n    }\n  }\n  /**\n   * Gets the appropriate SVG content based on the solid property\n   * @private\n   */\n  get svgContent() {\n    const constructor = this.constructor;\n    return this.solid ? constructor._solidSVG : constructor._regularSVG;\n  }\n  /**\n   * Applies stroke width to SVG paths if stroke property is set\n   * @private\n   */\n  applyStroke(content) {\n    if (!this.stroke) return content;\n    return content.replace(\n      /<(path|rect|circle|ellipse|line|polyline|polygon)/g,\n      `<$1 stroke-width=\"${this.stroke}\"`\n    );\n  }\n  /**\n   * Generates the SVG attributes string\n   * @private\n   */\n  generateAttributesString(attrs) {\n    return Object.entries(attrs).filter(([_, value]) => value !== void 0).map(([key, value]) => `${key}=\"${value}\"`).join(\"\\n      \");\n  }\n  render() {\n    const attrs = this.svgAttributes;\n    let content = this.svgContent || \"\";\n    if (this.stroke) {\n      content = this.applyStroke(content);\n    }\n    const svg = `\n      <svg ${this.generateAttributesString(attrs)}>\n        ${content}\n      </svg>\n    `;\n    return html`${unsafeHTML(svg)}`;\n  }\n}\nGdsIcon.styles = [tokens, IconStyles];\n__decorateClass([\n  styleExpressionProperty({\n    ...forSpaceTokensAndCustomValues,\n    property: \"height\",\n    selector: \"svg\"\n  })\n], GdsIcon.prototype, \"size\", 2);\n__decorateClass([\n  property({ type: Boolean })\n], GdsIcon.prototype, \"solid\", 2);\n__decorateClass([\n  property({ type: Number })\n], GdsIcon.prototype, \"stroke\", 2);\n__decorateClass([\n  property()\n], GdsIcon.prototype, \"level\", 2);\n__decorateClass([\n  styleExpressionProperty(forColorTokens(\"content\"))\n], GdsIcon.prototype, \"color\", 2);\n__decorateClass([\n  property({ type: String })\n], GdsIcon.prototype, \"label\", 2);\nexport {\n  GdsIcon\n};\n","import {\n  __decorateClass,\n  __privateAdd,\n  __privateGet,\n  __privateMethod,\n  __privateSet\n} from \"../../chunks/chunk.QU3DSPNU.js\";\nvar _handleChipClick, _collapseThreshold, _collapsedAt, _GdsFilterChips_instances, getChipHeight_fn, handleSlotChange_fn;\nimport { property, query, state } from \"lit/decorators.js\";\nimport { classMap } from \"lit/directives/class-map.js\";\nimport { resizeObserver } from \"../../utils/decorators/resize-observer.js\";\nimport { watch } from \"../../utils/decorators/watch.js\";\nimport { stringArrayConverter } from \"../../utils/helpers/attribute-converters.js\";\nimport {\n  gdsCustomElement,\n  html\n} from \"../../utils/helpers/custom-element-scoping.js\";\nimport { GdsFormControlElement } from \"../form/form-control.js\";\nimport { GdsFilterChip } from \"./filter-chip/filter-chip.component.js\";\nimport FilterChipsStyles from \"./filter-chips.styles.js\";\nlet GdsFilterChips = class extends GdsFormControlElement {\n  constructor() {\n    super(...arguments);\n    __privateAdd(this, _GdsFilterChips_instances);\n    this.multiple = false;\n    this.label = \"\";\n    this.rowCollapse = false;\n    this._collapsed = false;\n    __privateAdd(this, _handleChipClick, (event) => {\n      const clickedChip = this.chips.find(\n        (s) => s === event.target || s.contains(event.target)\n      );\n      if (clickedChip) {\n        if (this.multiple && Array.isArray(this.value)) {\n          if (clickedChip.selected) {\n            this.value = this.value.filter(\n              (v) => v !== clickedChip.value\n            );\n          } else {\n            this.value = [...this.value, clickedChip.value];\n          }\n        } else {\n          this.value = clickedChip.value === this.value ? void 0 : clickedChip.value;\n        }\n        this.dispatchCustomEvent(\"change\", {\n          detail: { clickedChip, value: this.value },\n          bubbles: true,\n          composed: true\n        });\n      }\n    });\n    __privateAdd(this, _collapseThreshold, 3);\n    __privateAdd(this, _collapsedAt, 0);\n  }\n  get value() {\n    return this._internalValue;\n  }\n  set value(value) {\n    this._internalValue = value;\n  }\n  /**\n   * Returns the chips in the control\n   * @readonly\n   */\n  get chips() {\n    return this._elSlot ? this._elSlot.assignedElements() : [];\n  }\n  render() {\n    const layoutClasses = {\n      collapse: this._collapsed\n    };\n    return html`<div\n      class=\"chips ${classMap(layoutClasses)}\"\n      role=\"listbox\"\n      aria-label=${this.label}\n      aria-multiselectable=${this.multiple}\n    >\n      <slot\n        @click=${__privateGet(this, _handleChipClick)}\n        @slotchange=${__privateMethod(this, _GdsFilterChips_instances, handleSlotChange_fn)}\n        role=\"none\"\n      ></slot>\n    </div>`;\n  }\n  focus(options) {\n    this.chips[0]?.focus(options);\n  }\n  _getValidityAnchor() {\n    return this.shadowRoot?.querySelector(\"div\");\n  }\n  _handleResize() {\n    if (!this.rowCollapse) return;\n    const chipHeight = __privateMethod(this, _GdsFilterChips_instances, getChipHeight_fn).call(this);\n    const selfHeight = this.offsetHeight;\n    const selfWidth = this.offsetWidth;\n    if (selfHeight >= chipHeight * __privateGet(this, _collapseThreshold)) {\n      this._collapsed = true;\n      __privateSet(this, _collapsedAt, selfWidth);\n    }\n    if (selfWidth > __privateGet(this, _collapsedAt)) {\n      this._collapsed = false;\n    }\n  }\n  _updateSelectedFromValue() {\n    if (this.multiple && !Array.isArray(this.value)) {\n      this.value = [this.value];\n    }\n    if (!this.multiple && Array.isArray(this.value)) {\n      this.value = this.value[0];\n    }\n    this.updateComplete.then(() => {\n      this.chips.forEach((chip) => {\n        chip.selected = this.multiple ? this.value.includes(chip.value) : this.value === chip.value;\n      });\n    });\n  }\n};\n_handleChipClick = new WeakMap();\n_collapseThreshold = new WeakMap();\n_collapsedAt = new WeakMap();\n_GdsFilterChips_instances = new WeakSet();\ngetChipHeight_fn = function() {\n  return this.chips[0]?.offsetHeight || 0;\n};\nhandleSlotChange_fn = function() {\n  if (this.value === void 0) {\n    if (!this.multiple) {\n      const selChipValue = this.chips.find((s) => s.selected)?.value;\n      if (selChipValue) {\n        this.value = selChipValue;\n      }\n    } else {\n      const selChipValues = this.chips.filter((s) => s.selected).map((s) => s.value);\n      if (selChipValues.length) {\n        this.value = selChipValues;\n      }\n    }\n  } else {\n    this._updateSelectedFromValue();\n  }\n};\nGdsFilterChips.styles = [FilterChipsStyles];\n__decorateClass([\n  property({ converter: stringArrayConverter })\n], GdsFilterChips.prototype, \"value\", 1);\n__decorateClass([\n  property({ type: Boolean })\n], GdsFilterChips.prototype, \"multiple\", 2);\n__decorateClass([\n  property()\n], GdsFilterChips.prototype, \"label\", 2);\n__decorateClass([\n  property({ type: Boolean, attribute: \"row-collapse\" })\n], GdsFilterChips.prototype, \"rowCollapse\", 2);\n__decorateClass([\n  state()\n], GdsFilterChips.prototype, \"_collapsed\", 2);\n__decorateClass([\n  query(\"slot\")\n], GdsFilterChips.prototype, \"_elSlot\", 2);\n__decorateClass([\n  resizeObserver()\n], GdsFilterChips.prototype, \"_handleResize\", 1);\n__decorateClass([\n  watch(\"value\")\n], GdsFilterChips.prototype, \"_updateSelectedFromValue\", 1);\nGdsFilterChips = __decorateClass([\n  gdsCustomElement(\"gds-filter-chips\", { dependsOn: [GdsFilterChip] })\n], GdsFilterChips);\nexport {\n  GdsFilterChip,\n  GdsFilterChips\n};\n"],"names":[],"ignoreList":[],"sourceRoot":""}