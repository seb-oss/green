{"version":3,"file":"src-lib-datepicker-datepicker-stories.138d328d.iframe.bundle.js","mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA8FA;AADA;AAAA;AAAA;AAAA;AAAA;;;;;AAIA;;AAHA;AADA;;AACA;;;;AA6HA;;;AAKA;;AADA;;;AACA;;AADA;;;AAcA;;;AAAA;AAFA;;;;AAGA;;AAYA;;AAAA;AADA;;;;AAGA;;AAFA","sources":["webpack://green/./dist/libs/core/src/components/alert/alert.component.js"],"sourcesContent":["import {\n  __decorateClass,\n  __privateAdd,\n  __privateGet,\n  __privateMethod,\n  __privateSet\n} from \"../../chunks/chunk.QU3DSPNU.js\";\nvar _timeoutId, _progressIntervalId, _alertRef, _observer, _isVisible, _remaining, _lastTick, _timerController, _GdsAlert_instances, setupObserver_fn, disconnectObserver_fn, startTicking_fn, resumeTimer_fn, pauseTimer_fn, clearTimers_fn, dismiss_fn, handleButtonClick_fn, handleKeyDown_fn, config_get, renderIcon_fn, renderMessage_fn, renderActionButton_fn, renderCloseButton_fn, renderProgressBar_fn;\nimport { localized, msg } from \"@lit/localize\";\nimport { nothing } from \"lit\";\nimport { property, state } from \"lit/decorators.js\";\nimport { classMap } from \"lit/directives/class-map.js\";\nimport { createRef, ref } from \"lit/directives/ref.js\";\nimport { html as staticHtml, unsafeStatic } from \"lit/static-html.js\";\nimport { GdsElement } from \"../../gds-element.js\";\nimport { gdsCustomElement, getScopedTagName, html } from \"../../scoping.js\";\nimport { tokens } from \"../../tokens.style.js\";\nimport { GdsButton } from \"../button/button.component.js\";\nimport { GdsCard } from \"../card/card.component.js\";\nimport { IconCircleCheck } from \"../icon/icons/circle-check.component.js\";\nimport { IconCircleInfo } from \"../icon/icons/circle-info.component.js\";\nimport { IconCrossSmall } from \"../icon/icons/cross-small.component.js\";\nimport { IconTriangleExclamation } from \"../icon/icons/triangle-exclamation.component.js\";\nimport AlertStyles from \"./alert.styles.js\";\nconst VARIANT_CONFIG = {\n  positive: { icon: \"circle-check\", card: \"positive\" },\n  warning: {\n    icon: \"circle-info\",\n    card: \"warning\"\n  },\n  negative: {\n    icon: \"triangle-exclamation\",\n    card: \"negative\"\n  },\n  information: {\n    icon: \"circle-info\",\n    card: \"information\"\n  },\n  notice: { icon: \"circle-info\", card: \"notice\" }\n};\nconst FADE_DURATION = 300;\nconst PROGRESS_INTERVAL = 100;\nlet GdsAlert = class extends GdsElement {\n  constructor() {\n    super();\n    __privateAdd(this, _GdsAlert_instances);\n    this.variant = \"information\";\n    this.label = \"\";\n    this.role = \"alert\";\n    this.dismissible = false;\n    this.timeout = 0;\n    this.buttonLabel = \"\";\n    this._progress = 100;\n    this._isClosing = false;\n    this._cardHidden = false;\n    __privateAdd(this, _timeoutId);\n    __privateAdd(this, _progressIntervalId);\n    __privateAdd(this, _alertRef, createRef());\n    __privateAdd(this, _observer);\n    __privateAdd(this, _isVisible, false);\n    __privateAdd(this, _remaining, 0);\n    __privateAdd(this, _lastTick, 0);\n    __privateAdd(this, _timerController, {\n      hostConnected: () => {\n        if (this.timeout > 0) {\n          __privateMethod(this, _GdsAlert_instances, setupObserver_fn).call(this);\n        }\n      },\n      hostDisconnected: () => {\n        __privateMethod(this, _GdsAlert_instances, disconnectObserver_fn).call(this);\n        __privateMethod(this, _GdsAlert_instances, clearTimers_fn).call(this);\n      }\n    });\n    this.addController(__privateGet(this, _timerController));\n  }\n  updated(changed) {\n    if (changed.has(\"timeout\")) {\n      __privateMethod(this, _GdsAlert_instances, disconnectObserver_fn).call(this);\n      __privateMethod(this, _GdsAlert_instances, clearTimers_fn).call(this);\n      __privateSet(this, _remaining, Math.max(0, this.timeout));\n      this._progress = 100;\n      if (this.timeout > 0) __privateMethod(this, _GdsAlert_instances, setupObserver_fn).call(this);\n    }\n  }\n  render() {\n    if (this._cardHidden) return nothing;\n    const classes = {\n      dismissing: this._isClosing,\n      dismissible: this.dismissible,\n      \"has-action\": this.buttonLabel,\n      timeout: this.timeout > 0\n    };\n    return html`\n      <gds-card\n        ${ref(__privateGet(this, _alertRef))}\n        role=${this.role}\n        aria-label=${this.label}\n        variant=${__privateGet(this, _GdsAlert_instances, config_get).card}\n        class=${classMap(classes)}\n        @keydown=${__privateMethod(this, _GdsAlert_instances, handleKeyDown_fn)}\n        id=\"alert-message\"\n        padding=\"m\"\n      >\n        <div class=\"wrapper\">\n          ${__privateMethod(this, _GdsAlert_instances, renderIcon_fn).call(this)} ${__privateMethod(this, _GdsAlert_instances, renderMessage_fn).call(this)}\n        </div>\n        ${!this.timeout && this.buttonLabel ? __privateMethod(this, _GdsAlert_instances, renderActionButton_fn).call(this, this.buttonLabel) : nothing}\n        ${__privateMethod(this, _GdsAlert_instances, renderCloseButton_fn).call(this)} ${__privateMethod(this, _GdsAlert_instances, renderProgressBar_fn).call(this)}\n      </gds-card>\n    `;\n  }\n};\n_timeoutId = new WeakMap();\n_progressIntervalId = new WeakMap();\n_alertRef = new WeakMap();\n_observer = new WeakMap();\n_isVisible = new WeakMap();\n_remaining = new WeakMap();\n_lastTick = new WeakMap();\n_timerController = new WeakMap();\n_GdsAlert_instances = new WeakSet();\nsetupObserver_fn = function() {\n  if (__privateGet(this, _observer)) return;\n  if (!__privateGet(this, _remaining)) __privateSet(this, _remaining, Math.max(0, this.timeout));\n  __privateSet(this, _observer, new IntersectionObserver(\n    (entries) => {\n      const entry = entries[0];\n      const ratio = entry?.intersectionRatio ?? 0;\n      const nowVisible = ratio >= 0.1;\n      if (nowVisible && !__privateGet(this, _isVisible)) {\n        __privateSet(this, _isVisible, true);\n        __privateMethod(this, _GdsAlert_instances, resumeTimer_fn).call(this);\n      } else if (!nowVisible && __privateGet(this, _isVisible)) {\n        __privateSet(this, _isVisible, false);\n        __privateMethod(this, _GdsAlert_instances, pauseTimer_fn).call(this);\n      }\n    },\n    {\n      root: null,\n      threshold: [0, 0.1, 1]\n    }\n  ));\n  __privateGet(this, _observer).observe(this);\n};\ndisconnectObserver_fn = function() {\n  if (__privateGet(this, _observer)) {\n    __privateGet(this, _observer).disconnect();\n    __privateSet(this, _observer, void 0);\n  }\n  __privateSet(this, _isVisible, false);\n};\n// Timer management (pausable)\nstartTicking_fn = function() {\n  __privateSet(this, _lastTick, Date.now());\n  __privateSet(this, _progressIntervalId, window.setInterval(() => {\n    const now = Date.now();\n    const dt = now - __privateGet(this, _lastTick);\n    __privateSet(this, _lastTick, now);\n    __privateSet(this, _remaining, Math.max(0, __privateGet(this, _remaining) - dt));\n    this._progress = this.timeout > 0 ? Math.max(0, __privateGet(this, _remaining) / this.timeout * 100) : 0;\n    if (__privateGet(this, _remaining) <= 0) {\n      __privateMethod(this, _GdsAlert_instances, dismiss_fn).call(this, \"timeout\");\n    }\n  }, PROGRESS_INTERVAL));\n};\nresumeTimer_fn = function() {\n  if (__privateGet(this, _remaining) <= 0 || __privateGet(this, _timeoutId) || __privateGet(this, _progressIntervalId))\n    return;\n  __privateMethod(this, _GdsAlert_instances, startTicking_fn).call(this);\n};\npauseTimer_fn = function() {\n  __privateMethod(this, _GdsAlert_instances, clearTimers_fn).call(this);\n};\nclearTimers_fn = function() {\n  clearTimeout(__privateGet(this, _timeoutId));\n  clearInterval(__privateGet(this, _progressIntervalId));\n  __privateSet(this, _timeoutId, __privateSet(this, _progressIntervalId, void 0));\n};\ndismiss_fn = async function(source) {\n  this._isClosing = true;\n  __privateMethod(this, _GdsAlert_instances, disconnectObserver_fn).call(this);\n  __privateMethod(this, _GdsAlert_instances, clearTimers_fn).call(this);\n  await this.updateComplete;\n  this.dispatchCustomEvent(\"gds-close\", {\n    detail: { source },\n    bubbles: true,\n    composed: true\n  });\n  await new Promise((r) => setTimeout(r, FADE_DURATION));\n  this._cardHidden = true;\n};\n// Event handlers\nhandleButtonClick_fn = function(e) {\n  this.dispatchCustomEvent(\"gds-action\", {\n    detail: { source: \"button\", event: e },\n    bubbles: true,\n    composed: true\n  });\n};\nhandleKeyDown_fn = function(e) {\n  if (e.key === \"Escape\" && this.dismissible) {\n    e.preventDefault();\n    __privateMethod(this, _GdsAlert_instances, dismiss_fn).call(this, \"escape\");\n  }\n};\nconfig_get = function() {\n  return VARIANT_CONFIG[this.variant];\n};\n// Render methods\nrenderIcon_fn = function() {\n  const icon = `gds-icon-${__privateGet(this, _GdsAlert_instances, config_get).icon}`;\n  return html`${staticHtml`<${unsafeStatic(getScopedTagName(icon))} class=\"icon\" solid aria-hidden=\"true\" size=\"24px\"></${unsafeStatic(getScopedTagName(icon))}>`}`;\n};\nrenderMessage_fn = function() {\n  return html`<div class=\"message\">\n      <span class=\"message-text\">\n        <slot></slot>\n      </span>\n    </div>`;\n};\nrenderActionButton_fn = function(label) {\n  return html`\n      <gds-button\n        class=\"action\"\n        .variant=${this.variant}\n        rank=\"secondary\"\n        @click=${__privateMethod(this, _GdsAlert_instances, handleButtonClick_fn)}\n        aria-describedby=\"alert-message\"\n      >\n        ${label.trim()}\n      </gds-button>\n    `;\n};\nrenderCloseButton_fn = function() {\n  return this.dismissible ? html`\n          <gds-button\n            class=\"close\"\n            .variant=${this.variant}\n            rank=\"secondary\"\n            size=\"small\"\n            aria-label=${msg(\"Dismiss alert\")}\n            @click=${() => __privateMethod(this, _GdsAlert_instances, dismiss_fn).call(this, \"close\")}\n          >\n            <gds-icon-cross-small size=\"20px\"></gds-icon-cross-small>\n          </gds-button>\n        ` : nothing;\n};\nrenderProgressBar_fn = function() {\n  return this.timeout > 0 ? html`\n          <div\n            class=${classMap({\n    \"progress-container\": true,\n    [this.variant]: true\n  })}\n            role=\"timer\"\n            aria-label=${msg(\"Auto-dismiss timer\")}\n            aria-valuenow=${this._progress}\n            aria-valuemin=\"0\"\n            aria-valuemax=\"100\"\n          >\n            <div class=\"timer-progress\" style=\"width: ${this._progress}%\"></div>\n          </div>\n        ` : nothing;\n};\nGdsAlert.styles = [tokens, AlertStyles];\n__decorateClass([\n  property({ type: String, reflect: true })\n], GdsAlert.prototype, \"variant\", 2);\n__decorateClass([\n  property({ type: String })\n], GdsAlert.prototype, \"label\", 2);\n__decorateClass([\n  property({ type: String, reflect: true })\n], GdsAlert.prototype, \"role\", 2);\n__decorateClass([\n  property({ type: Boolean })\n], GdsAlert.prototype, \"dismissible\", 2);\n__decorateClass([\n  property({ type: Number })\n], GdsAlert.prototype, \"timeout\", 2);\n__decorateClass([\n  property({ type: String, attribute: \"button-label\" })\n], GdsAlert.prototype, \"buttonLabel\", 2);\n__decorateClass([\n  state()\n], GdsAlert.prototype, \"_progress\", 2);\n__decorateClass([\n  state()\n], GdsAlert.prototype, \"_isClosing\", 2);\n__decorateClass([\n  state()\n], GdsAlert.prototype, \"_cardHidden\", 2);\nGdsAlert = __decorateClass([\n  gdsCustomElement(\"gds-alert\", {\n    dependsOn: [\n      GdsButton,\n      GdsCard,\n      IconCircleCheck,\n      IconTriangleExclamation,\n      IconCircleInfo,\n      IconCrossSmall\n    ]\n  }),\n  localized()\n], GdsAlert);\nexport {\n  GdsAlert\n};\n"],"names":[],"sourceRoot":""}