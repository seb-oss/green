{"version":3,"file":"7258.aa0874f1.iframe.bundle.js","mappings":";AA0QA;AAAA;;AACA;AADA;;;;;;AAKA;AALA;;;;;;AAKA;AALA;;AACA;AADA;;;AAEA;AC1JA;AAAA;;;AAEA","sources":["webpack://green/./dist/libs/core/src/chunks/chunk.CBUZ7ZHB.js","webpack://green/./dist/libs/core/src/chunks/chunk.DPKVKH5G.js"],"sourcesContent":["import {\n  resizeObserver\n} from \"./chunk.VHN4JEZC.js\";\nimport {\n  withLayoutChildProps,\n  withMarginProps,\n  withSizeXProps\n} from \"./chunk.TWXTKG4B.js\";\nimport {\n  TransitionalStyles\n} from \"./chunk.OUVNMCFD.js\";\nimport {\n  watch\n} from \"./chunk.TYGMNHNO.js\";\nimport {\n  tokens\n} from \"./chunk.D5VXMIQZ.js\";\nimport {\n  GdsElement\n} from \"./chunk.TMEWQZER.js\";\nimport {\n  gdsCustomElement,\n  html\n} from \"./chunk.QK3R23GV.js\";\nimport {\n  __decorateClass,\n  __privateAdd,\n  __privateGet,\n  __privateMethod,\n  __privateSet\n} from \"./chunk.SEHSDSX2.js\";\n\n// libs/core/src/components/segmented-control/segmented-control.ts\nimport { localized, msg } from \"@lit/localize\";\nimport { unsafeCSS } from \"lit\";\nimport { property, query, state } from \"lit/decorators.js\";\n\n// libs/core/src/components/segmented-control/segmented-control.style.css?inline\nvar segmented_control_style_default = `@layer base {\n  :host {\n    background-color: var(--gds-color-l3-background-secondary);\n    border: 0.25rem solid transparent;\n    border-radius: var(--gds-space-max);\n    box-sizing: border-box;\n    contain: layout;\n    display: inline-flex;\n    height: 3rem;\n    width: 100%;\n    position: relative;\n    overflow: hidden;\n  }\n\n  :host([size='small']) {\n    height: 2.5rem;\n  }\n\n  #track {\n    box-sizing: border-box;\n    display: flex;\n    flex-grow: 1;\n    scroll-snap-type: inline mandatory;\n    overscroll-behavior-x: contain;\n    scroll-behavior: smooth;\n    overflow-x: scroll;\n    gap: 0.25rem;\n    position: relative;\n    scrollbar-width: none;\n  }\n\n  #track::-webkit-scrollbar {\n    display: none;\n  }\n\n  #btn-prev,\n  #btn-next {\n    box-sizing: border-box;\n    align-items: center;\n    -webkit-appearance: none;\n       -moz-appearance: none;\n            appearance: none;\n    aspect-ratio: 1;\n    border-radius: var(--gds-space-max);\n    border-width: 0;\n    background-color: var(--gds-color-l3-background-secondary);\n    color: var(--gds-color-l3-content-tertiary);\n    cursor: pointer;\n    display: flex;\n    font-size: 1rem;\n    height: 100%;\n    justify-content: center;\n    width: 2.5rem;\n    transition: 0.2s;\n    z-index: 2;\n    position: absolute;\n\n    @media (pointer: fine) {\n      &:hover {\n        background-color: color-mix(\n          in srgb,\n          var(--gds-color-l3-background-secondary),\n          var(--gds-color-l3-states-light-hover)\n        );\n      }\n    }\n  }\n  #btn-prev {\n    margin: 0 0.25rem 0 0;\n  }\n  #btn-next {\n    margin: 0 0 0 0.25rem;\n    right: 0;\n  }\n\n  #btn-prev[aria-hidden='true'],\n  #btn-next[aria-hidden='true'] {\n    opacity: 0;\n    width: 0;\n    margin: 0;\n    padding: 0;\n  }\n\n  :host([size='small']) #btn-prev,\n  :host([size='small']) #btn-next {\n    width: 2rem;\n  }\n\n  ::slotted(*) {\n    flex-grow: 1;\n    flex-shrink: 0;\n    z-index: 1;\n    scroll-margin: 0 2.75rem;\n    scroll-snap-align: start;\n  }\n\n  #indicator {\n    background-color: var(--gds-color-l3-background-quarternary);\n    border-radius: var(--gds-space-max);\n    height: 100%;\n    left: 0;\n    position: absolute;\n    z-index: 0;\n    transition:\n      transform 0.2s,\n      width 0.2s;\n    z-index: 0;\n  }\n}\n`;\n\n// libs/core/src/components/segmented-control/segmented-control.ts\nvar debounce = (fn, delay) => {\n  let timeoutId;\n  return () => {\n    clearTimeout(timeoutId);\n    timeoutId = setTimeout(fn, delay);\n  };\n};\nvar _value, _handleSlotChange, handleSlotChange_fn, _scrollLeft, _scrollRight, _updateScrollBtnState, _updateScrollBtnStateDebounced, _updateIndicator, _handleSegmentClick, _updateSelectedFromValue;\nvar GdsSegmentedControl = class extends withLayoutChildProps(\n  withSizeXProps(withMarginProps(GdsElement))\n) {\n  constructor() {\n    super(...arguments);\n    __privateAdd(this, _handleSlotChange);\n    this.size = \"medium\";\n    __privateAdd(this, _value, void 0);\n    this._showPrevButton = false;\n    this._showNextButton = false;\n    this.intersectionObserver = null;\n    __privateAdd(this, _scrollLeft, () => {\n      const nextLeftOutOfView = this.segments.filter(\n        (s, i, arr) => {\n          var _a;\n          return ((_a = arr[i + 1]) == null ? void 0 : _a.isVisible) && !s.isVisible;\n        }\n      )[0];\n      if (!nextLeftOutOfView)\n        return;\n      this._elTrack.scrollLeft -= nextLeftOutOfView.offsetWidth;\n    });\n    __privateAdd(this, _scrollRight, () => {\n      const nextRightOutOfView = this.segments.filter((s, i, arr) => {\n        var _a;\n        return ((_a = arr[i - 1]) == null ? void 0 : _a.isVisible) && !s.isVisible;\n      }).reverse()[0];\n      if (!nextRightOutOfView)\n        return;\n      this._elTrack.scrollLeft += nextRightOutOfView.offsetWidth;\n    });\n    // Updates the visibility of the scroll buttons\n    __privateAdd(this, _updateScrollBtnState, () => {\n      if (this.segments.every((s) => !s.isVisible))\n        return;\n      this._showPrevButton = !this.segments[0].isVisible;\n      this._showNextButton = !this.segments[this.segments.length - 1].isVisible;\n    });\n    __privateAdd(this, _updateScrollBtnStateDebounced, debounce(__privateGet(this, _updateScrollBtnState), 50));\n    // Updates the selection indicator position\n    __privateAdd(this, _updateIndicator, () => {\n      const segment = this.segments.find((s) => s.selected);\n      if (segment) {\n        const segmentWidth = segment.offsetWidth;\n        const segmentLeft = segment.offsetLeft;\n        this._elIndicator.style.transform = `translateX(${segmentLeft}px)`;\n        this._elIndicator.style.width = `${segmentWidth}px`;\n      } else {\n        this._elIndicator.style.transform = `translateX(-100%)`;\n        this._elIndicator.style.width = `0px`;\n      }\n    });\n    __privateAdd(this, _handleSegmentClick, (event) => {\n      const selectedSegment = this.segments.find(\n        (s) => s === event.target || s.contains(event.target)\n      );\n      if (selectedSegment) {\n        this.segments.forEach((s) => s.selected = false);\n        selectedSegment.selected = true;\n        __privateSet(this, _value, selectedSegment.value);\n        __privateGet(this, _updateIndicator).call(this);\n        this.dispatchEvent(\n          new CustomEvent(\"change\", {\n            detail: { segment: selectedSegment },\n            bubbles: true,\n            composed: true\n          })\n        );\n      }\n    });\n    __privateAdd(this, _updateSelectedFromValue, () => {\n      if (!__privateGet(this, _value))\n        return;\n      this.updateComplete.then(() => {\n        const selectedSegment = this.segments.find((s) => s.value === __privateGet(this, _value));\n        if (selectedSegment) {\n          this.segments.forEach((s) => s.selected = false);\n          selectedSegment.selected = true;\n          this._elTrack.scrollLeft = selectedSegment.offsetLeft;\n        }\n      });\n    });\n  }\n  get value() {\n    return __privateGet(this, _value);\n  }\n  set value(val) {\n    __privateSet(this, _value, val);\n    __privateGet(this, _updateSelectedFromValue).call(this);\n  }\n  /**\n   * Returns the segments in the control\n   * @readonly\n   */\n  get segments() {\n    return this._elSlot ? this._elSlot.assignedElements() : [];\n  }\n  connectedCallback() {\n    super.connectedCallback();\n    TransitionalStyles.instance.apply(this, \"gds-segmented-control\");\n    this.updateComplete.then(() => {\n      this._elTrack.addEventListener(\"scroll\", () => {\n        __privateGet(this, _updateScrollBtnStateDebounced).call(this);\n      });\n    });\n  }\n  render() {\n    return html`<button\n        aria-hidden=${!this._showPrevButton}\n        ?inert=${!this._showPrevButton}\n        id=\"btn-prev\"\n        @click=${__privateGet(this, _scrollLeft)}\n        aria-label=${msg(\"Scroll right\")}\n      >\n        <gds-icon-chevron-left />\n      </button>\n      <div id=\"track\" role=\"list\">\n        <slot\n          @click=${__privateGet(this, _handleSegmentClick)}\n          @slotchange=${__privateMethod(this, _handleSlotChange, handleSlotChange_fn)}\n          role=\"none\"\n        ></slot>\n        <div id=\"indicator\" role=\"none\"></div>\n      </div>\n      <button\n        aria-hidden=${!this._showNextButton}\n        ?inert=${!this._showNextButton}\n        id=\"btn-next\"\n        @click=${__privateGet(this, _scrollRight)}\n        aria-label=${msg(\"Scroll right\")}\n      >\n        <gds-icon-chevron-right />\n      </button>`;\n  }\n  _recalculateMinWidth() {\n    this.updateComplete.then(() => {\n      __privateGet(this, _updateScrollBtnStateDebounced).call(this);\n      __privateGet(this, _updateIndicator).call(this);\n    });\n  }\n};\n_value = new WeakMap();\n_handleSlotChange = new WeakSet();\nhandleSlotChange_fn = function() {\n  var _a, _b;\n  const selSegmentValue = (_a = this.segments.find((s) => s.selected)) == null ? void 0 : _a.value;\n  if (selSegmentValue) {\n    __privateSet(this, _value, selSegmentValue);\n  }\n  (_b = this.intersectionObserver) == null ? void 0 : _b.disconnect();\n  this.intersectionObserver = new IntersectionObserver(\n    (entries) => {\n      entries.forEach((entry) => {\n        const segment = entry.target;\n        segment._isVisible = entry.intersectionRatio > 0.99;\n        __privateGet(this, _updateScrollBtnStateDebounced).call(this);\n      });\n    },\n    {\n      root: this._elTrack,\n      threshold: [0, 0.01, 0.5, 0.99, 1]\n    }\n  );\n  this.segments.forEach((s) => {\n    var _a2;\n    (_a2 = this.intersectionObserver) == null ? void 0 : _a2.observe(s);\n  });\n};\n_scrollLeft = new WeakMap();\n_scrollRight = new WeakMap();\n_updateScrollBtnState = new WeakMap();\n_updateScrollBtnStateDebounced = new WeakMap();\n_updateIndicator = new WeakMap();\n_handleSegmentClick = new WeakMap();\n_updateSelectedFromValue = new WeakMap();\nGdsSegmentedControl.styles = [tokens, unsafeCSS(segmented_control_style_default)];\n__decorateClass([\n  property({ reflect: true })\n], GdsSegmentedControl.prototype, \"size\", 2);\n__decorateClass([\n  property()\n], GdsSegmentedControl.prototype, \"value\", 1);\n__decorateClass([\n  query(\"slot\")\n], GdsSegmentedControl.prototype, \"_elSlot\", 2);\n__decorateClass([\n  query(\"#indicator\")\n], GdsSegmentedControl.prototype, \"_elIndicator\", 2);\n__decorateClass([\n  query(\"#track\")\n], GdsSegmentedControl.prototype, \"_elTrack\", 2);\n__decorateClass([\n  state()\n], GdsSegmentedControl.prototype, \"_showPrevButton\", 2);\n__decorateClass([\n  state()\n], GdsSegmentedControl.prototype, \"_showNextButton\", 2);\n__decorateClass([\n  resizeObserver(),\n  watch(\"value\")\n], GdsSegmentedControl.prototype, \"_recalculateMinWidth\", 1);\nGdsSegmentedControl = __decorateClass([\n  gdsCustomElement(\"gds-segmented-control\"),\n  localized()\n], GdsSegmentedControl);\n\nexport {\n  GdsSegmentedControl\n};\n","import {\n  withSizeXProps\n} from \"./chunk.TWXTKG4B.js\";\nimport {\n  TransitionalStyles\n} from \"./chunk.OUVNMCFD.js\";\nimport {\n  tokens\n} from \"./chunk.D5VXMIQZ.js\";\nimport {\n  GdsElement\n} from \"./chunk.TMEWQZER.js\";\nimport {\n  gdsCustomElement,\n  html\n} from \"./chunk.QK3R23GV.js\";\nimport {\n  __decorateClass\n} from \"./chunk.SEHSDSX2.js\";\n\n// libs/core/src/components/segmented-control/segment/segment.ts\nimport { unsafeCSS } from \"lit\";\nimport { property } from \"lit/decorators.js\";\n\n// libs/core/src/components/segmented-control/segment/segment.style.css?inline\nvar segment_style_default = `@layer base {\n  :host {\n    display: flex;\n    z-index: 1;\n  }\n\n  button {\n    -webkit-appearance: none;\n       -moz-appearance: none;\n            appearance: none;\n    background: transparent;\n    border-radius: var(--gds-space-max);\n    border-width: 0;\n    color: var(--gds-color-l3-content-tertiary);\n    cursor: pointer;\n    flex-grow: 1;\n    flex-shrink: 0;\n    font-family: inherit;\n    font-size: inherit;\n    overflow: hidden;\n    padding: 0 1rem;\n    text-align: center;\n    text-overflow: ellipsis;\n    white-space: nowrap;\n    width: 100%;\n    transition:\n      background-color 0.2s,\n      border-color 0.2s,\n      color 0.2s,\n      outline-color 422ms;\n\n    outline-width: var(--gds-size-3xs);\n    outline-style: solid;\n    outline-offset: -2px;\n    outline-color: transparent;\n\n    &:disabled {\n      cursor: not-allowed;\n      opacity: 0.5;\n    }\n  }\n\n  @media (pointer: fine) {\n    :host(:not([selected])) button:hover {\n      background-color: color-mix(\n        in srgb,\n        var(--gds-color-l3-states-light-hover),\n        transparent\n      );\n\n      &:disabled {\n        background-color: transparent;\n      }\n    }\n  }\n\n  button:focus-visible {\n    outline-color: color-mix(\n      in srgb,\n      transparent,\n      var(--gds-color-l3-content-tertiary) 100%\n    );\n  }\n}\n`;\n\n// libs/core/src/components/segmented-control/segment/segment.ts\nvar GdsSegment = class extends withSizeXProps(GdsElement) {\n  constructor() {\n    super(...arguments);\n    this.selected = false;\n    this.disabled = false;\n    // This is deliberatly not marked as private, since we're setting it from the parent component,\n    // but it is not meant to be set by the consumer.\n    this._isVisible = true;\n  }\n  /**\n   * Whether the segment is currently visible.\n   */\n  get isVisible() {\n    return this._isVisible;\n  }\n  connectedCallback() {\n    super.connectedCallback();\n    TransitionalStyles.instance.apply(this, \"gds-segmented\");\n    this.setAttribute(\"role\", \"listitem\");\n  }\n  render() {\n    return html`<button\n      aria-current=${String(this.selected)}\n      ?disabled=\"${this.disabled}\"\n    >\n      <slot></slot>\n    </button>`;\n  }\n};\nGdsSegment.styles = [...tokens, unsafeCSS(segment_style_default)];\n__decorateClass([\n  property({ type: Boolean, reflect: true })\n], GdsSegment.prototype, \"selected\", 2);\n__decorateClass([\n  property()\n], GdsSegment.prototype, \"value\", 2);\n__decorateClass([\n  property({ type: Boolean, reflect: true })\n], GdsSegment.prototype, \"disabled\", 2);\nGdsSegment = __decorateClass([\n  gdsCustomElement(\"gds-segment\")\n], GdsSegment);\n\nexport {\n  GdsSegment\n};\n"],"names":[],"sourceRoot":""}