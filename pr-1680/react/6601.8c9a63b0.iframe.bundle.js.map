{"version":3,"file":"6601.8c9a63b0.iframe.bundle.js","mappings":";AA6PA;AAAA;;AACA;AADA;;;;;;AAKA;AALA;;;;;;AAKA;AALA;;AACA;AADA;;;AAEA;AC3JA;AAAA;;;AAEA","sources":["webpack://green/./dist/libs/core/src/chunks/chunk.SJPIIPZ6.js","webpack://green/./dist/libs/core/src/chunks/chunk.TTTPYOCR.js"],"sourcesContent":["import {\n  resizeObserver\n} from \"./chunk.VHN4JEZC.js\";\nimport {\n  TransitionalStyles\n} from \"./chunk.TQCUATGL.js\";\nimport {\n  watch\n} from \"./chunk.TYGMNHNO.js\";\nimport {\n  tokens\n} from \"./chunk.4ZTW2TLE.js\";\nimport {\n  GdsElement\n} from \"./chunk.WIZDAKJ5.js\";\nimport {\n  gdsCustomElement,\n  html\n} from \"./chunk.MLXMQIEV.js\";\nimport {\n  __decorateClass,\n  __privateAdd,\n  __privateGet,\n  __privateMethod,\n  __privateSet\n} from \"./chunk.SEHSDSX2.js\";\n\n// libs/core/src/components/segmented-control/segmented-control.ts\nimport { unsafeCSS } from \"lit\";\nimport { query, state, property } from \"lit/decorators.js\";\nimport { msg } from \"@lit/localize\";\n\n// libs/core/src/components/segmented-control/segmented-control.style.css?inline\nvar segmented_control_style_default = `:host {\n  background-color: var(--gds-sys-color-container-container-dim1);\n  border: 0.25rem solid var(--gds-sys-color-container-container-dim1);\n  border-radius: calc(infinity * 1px);\n  box-sizing: border-box;\n  contain: layout;\n  display: inline-flex;\n  height: 3rem;\n  width: 100%;\n  position: relative;\n  overflow: hidden;\n}\n\n:host([size='small']) {\n  height: 2.5rem;\n}\n\n#track {\n  box-sizing: border-box;\n  display: flex;\n  flex-grow: 1;\n  scroll-snap-type: inline mandatory;\n  overscroll-behavior-x: contain;\n  scroll-behavior: smooth;\n  overflow-x: scroll;\n  gap: 0.25rem;\n  position: relative;\n  scrollbar-width: none;\n}\n\n#track::-webkit-scrollbar {\n  display: none;\n}\n\n#btn-prev,\n#btn-next {\n  box-sizing: border-box;\n  align-items: center;\n  -webkit-appearance: none;\n     -moz-appearance: none;\n          appearance: none;\n  aspect-ratio: 1;\n  background-color: var(--gds-sys-color-container-container-dim1);\n  border-radius: calc(infinity * 1px);\n  border-width: 0;\n  color: var(--gds-sys-color-content-content);\n  cursor: pointer;\n  display: flex;\n  font-size: 1rem;\n  height: 100%;\n  justify-content: center;\n  width: 2.5rem;\n  transition: 0.2s;\n  z-index: 2;\n  position: absolute;\n\n  @media (pointer: fine) {\n    &:hover {\n      background-color: color-mix(\n        in srgb,\n        var(--gds-sys-color-state-layers-state-black-dim1),\n        var(--gds-sys-color-container-container-dim1)\n      );\n    }\n  }\n}\n#btn-prev {\n  margin: 0 0.25rem 0 0;\n}\n#btn-next {\n  margin: 0 0 0 0.25rem;\n  right: 0;\n}\n\n#btn-prev[aria-hidden='true'],\n#btn-next[aria-hidden='true'] {\n  opacity: 0;\n  width: 0;\n  margin: 0;\n  padding: 0;\n}\n\n:host([size='small']) #btn-prev,\n:host([size='small']) #btn-next {\n  width: 2rem;\n}\n\n::slotted(*) {\n  flex-grow: 1;\n  flex-shrink: 0;\n  z-index: 1;\n  scroll-margin: 0 2.75rem;\n  scroll-snap-align: start;\n}\n\n#indicator {\n  background-color: var(--gds-sys-color-container-container-bright);\n  border-radius: calc(infinity * 1px);\n  height: 100%;\n  left: 0;\n  position: absolute;\n  z-index: 0;\n  transition:\n    transform 0.2s,\n    width 0.2s;\n  z-index: 0;\n}\n`;\n\n// libs/core/src/components/segmented-control/segmented-control.ts\nvar debounce = (fn, delay) => {\n  let timeoutId;\n  return () => {\n    clearTimeout(timeoutId);\n    timeoutId = setTimeout(fn, delay);\n  };\n};\nvar _value, _handleSlotChange, handleSlotChange_fn, _scrollLeft, _scrollRight, _updateScrollBtnState, _updateScrollBtnStateDebounced, _updateIndicator, _handleSegmentClick, _updateSelectedFromValue;\nvar GdsSegmentedControl = class extends GdsElement {\n  constructor() {\n    super(...arguments);\n    __privateAdd(this, _handleSlotChange);\n    this.size = \"medium\";\n    __privateAdd(this, _value, void 0);\n    this._showPrevButton = false;\n    this._showNextButton = false;\n    this.intersectionObserver = null;\n    __privateAdd(this, _scrollLeft, () => {\n      const nextLeftOutOfView = this.segments.filter(\n        (s, i, arr) => {\n          var _a;\n          return ((_a = arr[i + 2]) == null ? void 0 : _a.isVisible) && !s.isVisible;\n        }\n      )[0];\n      nextLeftOutOfView.scrollIntoView();\n    });\n    __privateAdd(this, _scrollRight, () => {\n      const nextRightOutOfView = this.segments.filter((s, i, arr) => {\n        var _a;\n        return ((_a = arr[i - 2]) == null ? void 0 : _a.isVisible) && !s.isVisible;\n      }).reverse()[0];\n      nextRightOutOfView.scrollIntoView();\n    });\n    // Updates the visibility of the scroll buttons\n    __privateAdd(this, _updateScrollBtnState, () => {\n      if (this.segments.every((s) => !s.isVisible))\n        return;\n      this._showPrevButton = !this.segments[0].isVisible;\n      this._showNextButton = !this.segments[this.segments.length - 1].isVisible;\n    });\n    __privateAdd(this, _updateScrollBtnStateDebounced, debounce(__privateGet(this, _updateScrollBtnState), 50));\n    // Updates the selection indicator position\n    __privateAdd(this, _updateIndicator, () => {\n      const segment = this.segments.find((s) => s.selected);\n      if (segment) {\n        const segmentWidth = segment.offsetWidth;\n        const segmentLeft = segment.offsetLeft;\n        this._elIndicator.style.transform = `translateX(${segmentLeft}px)`;\n        this._elIndicator.style.width = `${segmentWidth}px`;\n      } else {\n        this._elIndicator.style.transform = `translateX(-100%)`;\n        this._elIndicator.style.width = `0px`;\n      }\n    });\n    __privateAdd(this, _handleSegmentClick, (event) => {\n      const selectedSegment = this.segments.find(\n        (s) => s === event.target || s.contains(event.target)\n      );\n      if (selectedSegment) {\n        this.segments.forEach((s) => s.selected = false);\n        selectedSegment.selected = true;\n        __privateSet(this, _value, selectedSegment.value);\n        __privateGet(this, _updateIndicator).call(this);\n        this.dispatchEvent(\n          new CustomEvent(\"change\", {\n            detail: { segment: selectedSegment },\n            bubbles: true,\n            composed: true\n          })\n        );\n      }\n    });\n    __privateAdd(this, _updateSelectedFromValue, () => {\n      if (!__privateGet(this, _value))\n        return;\n      this.updateComplete.then(() => {\n        const selectedSegment = this.segments.find((s) => s.value === __privateGet(this, _value));\n        if (selectedSegment) {\n          this.segments.forEach((s) => s.selected = false);\n          selectedSegment.selected = true;\n          selectedSegment.scrollIntoView();\n        }\n      });\n    });\n  }\n  get value() {\n    return __privateGet(this, _value);\n  }\n  set value(val) {\n    __privateSet(this, _value, val);\n    __privateGet(this, _updateSelectedFromValue).call(this);\n  }\n  /**\n   * Returns the segments in the control\n   * @readonly\n   */\n  get segments() {\n    return this._elSlot ? this._elSlot.assignedElements() : [];\n  }\n  connectedCallback() {\n    super.connectedCallback();\n    TransitionalStyles.instance.apply(this, \"gds-segmented-control\");\n    this.updateComplete.then(() => {\n      this._elTrack.addEventListener(\"scroll\", () => {\n        __privateGet(this, _updateScrollBtnStateDebounced).call(this);\n      });\n    });\n  }\n  render() {\n    return html`<button\n        aria-hidden=${!this._showPrevButton}\n        ?inert=${!this._showPrevButton}\n        id=\"btn-prev\"\n        @click=${__privateGet(this, _scrollLeft)}\n        aria-label=${msg(\"Scroll right\")}\n      >\n        <gds-icon-chevron-left />\n      </button>\n      <div id=\"track\" role=\"list\">\n        <slot\n          @click=${__privateGet(this, _handleSegmentClick)}\n          @slotchange=${__privateMethod(this, _handleSlotChange, handleSlotChange_fn)}\n          role=\"none\"\n        ></slot>\n        <div id=\"indicator\" role=\"none\"></div>\n      </div>\n      <button\n        aria-hidden=${!this._showNextButton}\n        ?inert=${!this._showNextButton}\n        id=\"btn-next\"\n        @click=${__privateGet(this, _scrollRight)}\n        aria-label=${msg(\"Scroll right\")}\n      >\n        <gds-icon-chevron-right />\n      </button>`;\n  }\n  _recalculateMinWidth() {\n    this.updateComplete.then(() => {\n      __privateGet(this, _updateScrollBtnStateDebounced).call(this);\n      __privateGet(this, _updateIndicator).call(this);\n    });\n  }\n};\n_value = new WeakMap();\n_handleSlotChange = new WeakSet();\nhandleSlotChange_fn = function() {\n  var _a, _b;\n  const selSegmentValue = (_a = this.segments.find((s) => s.selected)) == null ? void 0 : _a.value;\n  if (selSegmentValue) {\n    __privateSet(this, _value, selSegmentValue);\n  }\n  (_b = this.intersectionObserver) == null ? void 0 : _b.disconnect();\n  this.intersectionObserver = new IntersectionObserver(\n    (entries) => {\n      entries.forEach((entry) => {\n        const segment = entry.target;\n        segment._isVisible = entry.intersectionRatio > 0.99;\n      });\n    },\n    {\n      root: this._elTrack,\n      threshold: [0, 0.01, 0.5, 0.99, 1]\n    }\n  );\n  this.segments.forEach((s) => {\n    var _a2;\n    (_a2 = this.intersectionObserver) == null ? void 0 : _a2.observe(s);\n  });\n};\n_scrollLeft = new WeakMap();\n_scrollRight = new WeakMap();\n_updateScrollBtnState = new WeakMap();\n_updateScrollBtnStateDebounced = new WeakMap();\n_updateIndicator = new WeakMap();\n_handleSegmentClick = new WeakMap();\n_updateSelectedFromValue = new WeakMap();\nGdsSegmentedControl.styles = [tokens, unsafeCSS(segmented_control_style_default)];\n__decorateClass([\n  property({ reflect: true })\n], GdsSegmentedControl.prototype, \"size\", 2);\n__decorateClass([\n  property()\n], GdsSegmentedControl.prototype, \"value\", 1);\n__decorateClass([\n  query(\"slot\")\n], GdsSegmentedControl.prototype, \"_elSlot\", 2);\n__decorateClass([\n  query(\"#indicator\")\n], GdsSegmentedControl.prototype, \"_elIndicator\", 2);\n__decorateClass([\n  query(\"#track\")\n], GdsSegmentedControl.prototype, \"_elTrack\", 2);\n__decorateClass([\n  state()\n], GdsSegmentedControl.prototype, \"_showPrevButton\", 2);\n__decorateClass([\n  state()\n], GdsSegmentedControl.prototype, \"_showNextButton\", 2);\n__decorateClass([\n  resizeObserver(),\n  watch(\"segMinWidth\")\n], GdsSegmentedControl.prototype, \"_recalculateMinWidth\", 1);\nGdsSegmentedControl = __decorateClass([\n  gdsCustomElement(\"gds-segmented-control\")\n], GdsSegmentedControl);\n\nexport {\n  GdsSegmentedControl\n};\n","import {\n  styleExpressionProperty\n} from \"./chunk.6UWYSL2J.js\";\nimport {\n  TransitionalStyles\n} from \"./chunk.TQCUATGL.js\";\nimport {\n  tokens\n} from \"./chunk.4ZTW2TLE.js\";\nimport {\n  GdsElement\n} from \"./chunk.WIZDAKJ5.js\";\nimport {\n  gdsCustomElement,\n  html\n} from \"./chunk.MLXMQIEV.js\";\nimport {\n  __decorateClass\n} from \"./chunk.SEHSDSX2.js\";\n\n// libs/core/src/components/segmented-control/segment/segment.ts\nimport { property } from \"lit/decorators.js\";\nimport { unsafeCSS } from \"lit\";\n\n// libs/core/src/components/segmented-control/segment/segment.style.css?inline\nvar segment_style_default = `:host {\n  display: flex;\n  z-index: 1;\n}\n\nbutton {\n  -webkit-appearance: none;\n     -moz-appearance: none;\n          appearance: none;\n  background: transparent;\n  border-radius: calc(infinity * 1px);\n  border-width: 0;\n  color: var(--gds-sys-color-content-content);\n  cursor: pointer;\n  flex-grow: 1;\n  flex-shrink: 0;\n  font-family: inherit;\n  font-size: inherit;\n  overflow: hidden;\n  padding: 0 1rem;\n  text-align: center;\n  text-overflow: ellipsis;\n  white-space: nowrap;\n  width: 100%;\n  transition: 0.1s;\n\n  &:disabled {\n    cursor: not-allowed;\n    opacity: 0.5;\n  }\n}\n\n@media (pointer: fine) {\n  :host(:not([selected])) button:hover {\n    background-color: color-mix(\n      in srgb,\n      var(--gds-sys-color-state-layers-state-black-dim1),\n      transparent\n    );\n\n    &:disabled {\n      background-color: transparent;\n    }\n  }\n}\n\nbutton:focus-visible {\n  outline: 2px solid #000;\n  outline-offset: -2px;\n}\n`;\n\n// libs/core/src/components/segmented-control/segment/segment.ts\nvar GdsSegment = class extends GdsElement {\n  constructor() {\n    super(...arguments);\n    this.selected = false;\n    this.disabled = false;\n    // This is deliberatly not marked as private, since we're setting it from the parent component,\n    // but it is not meant to be set by the consumer.\n    this._isVisible = true;\n  }\n  /**\n   * Whether the segment is currently visible.\n   */\n  get isVisible() {\n    return this._isVisible;\n  }\n  connectedCallback() {\n    super.connectedCallback();\n    TransitionalStyles.instance.apply(this, \"gds-segmented\");\n    this.setAttribute(\"role\", \"listitem\");\n  }\n  render() {\n    return html`<button\n      aria-current=${String(this.selected)}\n      ?disabled=\"${this.disabled}\"\n    >\n      <slot></slot>\n    </button>`;\n  }\n};\nGdsSegment.styles = [...tokens, unsafeCSS(segment_style_default)];\n__decorateClass([\n  property({ type: Boolean, reflect: true })\n], GdsSegment.prototype, \"selected\", 2);\n__decorateClass([\n  property()\n], GdsSegment.prototype, \"value\", 2);\n__decorateClass([\n  property({ type: Boolean, reflect: true })\n], GdsSegment.prototype, \"disabled\", 2);\n__decorateClass([\n  styleExpressionProperty({\n    valueTemplate: (v) => v\n  })\n], GdsSegment.prototype, \"min-width\", 2);\n__decorateClass([\n  styleExpressionProperty({\n    valueTemplate: (v) => v\n  })\n], GdsSegment.prototype, \"max-width\", 2);\n__decorateClass([\n  styleExpressionProperty()\n], GdsSegment.prototype, \"width\", 2);\nGdsSegment = __decorateClass([\n  gdsCustomElement(\"gds-segment\")\n], GdsSegment);\n\nexport {\n  GdsSegment\n};\n"],"names":[],"sourceRoot":""}