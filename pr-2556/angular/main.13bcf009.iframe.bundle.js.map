{"version":3,"file":"main.13bcf009.iframe.bundle.js","mappings":";;;;;;;AAiaA;;;;;;;AAeA;;;;;;;AAaA","sources":["webpack://green/./node_modules/@storybook/angular/dist/_browser-chunks/chunk-L4GU2V72.js"],"sourcesContent":["var __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __name = (target, value) => __defProp(target, \"name\", { value, configurable: true });\nvar __export = (target, all) => {\n  for (var name in all)\n    __defProp(target, name, { get: all[name], enumerable: true });\n};\nvar __decorateClass = (decorators, target, key, kind) => {\n  var result = kind > 1 ? void 0 : kind ? __getOwnPropDesc(target, key) : target;\n  for (var i = decorators.length - 1, decorator; i >= 0; i--)\n    if (decorator = decorators[i])\n      result = (kind ? decorator(target, key, result) : decorator(result)) || result;\n  if (kind && result) __defProp(target, key, result);\n  return result;\n};\nvar __decorateParam = (index, decorator) => (target, key) => decorator(target, key, index);\n\n// src/client/render.ts\nvar render_exports = {};\n__export(render_exports, {\n  render: () => render,\n  renderToCanvas: () => renderToCanvas,\n  rendererFactory: () => rendererFactory\n});\nimport \"@angular/compiler\";\n\n// src/client/angular-beta/AbstractRenderer.ts\nimport { bootstrapApplication } from \"@angular/platform-browser\";\nimport { BehaviorSubject } from \"rxjs\";\nimport { stringify } from \"telejson\";\n\n// src/client/angular-beta/utils/NgComponentAnalyzer.ts\nimport {\n  Component,\n  Directive,\n  Input,\n  Output,\n  Pipe,\n  \\u0275ReflectionCapabilities as ReflectionCapabilities\n} from \"@angular/core\";\nvar reflectionCapabilities = new ReflectionCapabilities();\nvar getComponentInputsOutputs = /* @__PURE__ */ __name((component) => {\n  const componentMetadata = getComponentDecoratorMetadata(component);\n  const componentPropsMetadata = getComponentPropsDecoratorMetadata(component);\n  const initialValue = {\n    inputs: [],\n    outputs: []\n  };\n  if (componentMetadata && componentMetadata.inputs) {\n    initialValue.inputs.push(\n      ...componentMetadata.inputs.map((i) => ({\n        propName: typeof i === \"string\" ? i : i.name,\n        templateName: typeof i === \"string\" ? i : i.alias\n      }))\n    );\n  }\n  if (componentMetadata && componentMetadata.outputs) {\n    initialValue.outputs.push(\n      ...componentMetadata.outputs.map((i) => ({ propName: i, templateName: i }))\n    );\n  }\n  if (!componentPropsMetadata) {\n    return initialValue;\n  }\n  return Object.entries(componentPropsMetadata).reduce((previousValue, [propertyName, values]) => {\n    const value = values.find((v) => v instanceof Input || v instanceof Output);\n    if (value instanceof Input) {\n      const inputToAdd = {\n        propName: propertyName,\n        templateName: value.bindingPropertyName ?? value.alias ?? propertyName\n      };\n      const previousInputsFiltered = previousValue.inputs.filter(\n        (i) => i.templateName !== propertyName\n      );\n      return {\n        ...previousValue,\n        inputs: [...previousInputsFiltered, inputToAdd]\n      };\n    }\n    if (value instanceof Output) {\n      const outputToAdd = {\n        propName: propertyName,\n        templateName: value.bindingPropertyName ?? value.alias ?? propertyName\n      };\n      const previousOutputsFiltered = previousValue.outputs.filter(\n        (i) => i.templateName !== propertyName\n      );\n      return {\n        ...previousValue,\n        outputs: [...previousOutputsFiltered, outputToAdd]\n      };\n    }\n    return previousValue;\n  }, initialValue);\n}, \"getComponentInputsOutputs\");\nvar isComponent = /* @__PURE__ */ __name((component) => {\n  if (!component) {\n    return false;\n  }\n  const decorators = reflectionCapabilities.annotations(component);\n  return (decorators || []).some((d) => d instanceof Component);\n}, \"isComponent\");\nvar getComponentPropsDecoratorMetadata = /* @__PURE__ */ __name((component) => {\n  return reflectionCapabilities.propMetadata(component);\n}, \"getComponentPropsDecoratorMetadata\");\nvar getComponentDecoratorMetadata = /* @__PURE__ */ __name((component) => {\n  const decorators = reflectionCapabilities.annotations(component);\n  return decorators.reverse().find((d) => d instanceof Component);\n}, \"getComponentDecoratorMetadata\");\n\n// src/client/angular-beta/ComputesTemplateFromComponent.ts\nvar isValidIdentifier = /* @__PURE__ */ __name((name) => /^[a-zA-Z_$][a-zA-Z0-9_$]*$/.test(name), \"isValidIdentifier\");\nvar formatPropInTemplate = /* @__PURE__ */ __name((propertyName) => isValidIdentifier(propertyName) ? propertyName : `this['${propertyName}']`, \"formatPropInTemplate\");\nvar separateInputsOutputsAttributes = /* @__PURE__ */ __name((ngComponentInputsOutputs, props = {}) => {\n  const inputs = ngComponentInputsOutputs.inputs.filter((i) => i.templateName in props).map((i) => i.templateName);\n  const outputs = ngComponentInputsOutputs.outputs.filter((o) => o.templateName in props).map((o) => o.templateName);\n  return {\n    inputs,\n    outputs,\n    otherProps: Object.keys(props).filter((k) => ![...inputs, ...outputs].includes(k))\n  };\n}, \"separateInputsOutputsAttributes\");\nvar computesTemplateFromComponent = /* @__PURE__ */ __name((component, initialProps, innerTemplate = \"\") => {\n  const ngComponentMetadata = getComponentDecoratorMetadata(component);\n  const ngComponentInputsOutputs = getComponentInputsOutputs(component);\n  if (!ngComponentMetadata.selector) {\n    return `<ng-container *ngComponentOutlet=\"storyComponent\"></ng-container>`;\n  }\n  const { inputs: initialInputs, outputs: initialOutputs } = separateInputsOutputsAttributes(\n    ngComponentInputsOutputs,\n    initialProps\n  );\n  const templateInputs = initialInputs.length > 0 ? ` ${initialInputs.map((i) => `[${i}]=\"${formatPropInTemplate(i)}\"`).join(\" \")}` : \"\";\n  const templateOutputs = initialOutputs.length > 0 ? ` ${initialOutputs.map((i) => `(${i})=\"${formatPropInTemplate(i)}($event)\"`).join(\" \")}` : \"\";\n  return buildTemplate(\n    ngComponentMetadata.selector,\n    innerTemplate,\n    templateInputs,\n    templateOutputs\n  );\n}, \"computesTemplateFromComponent\");\nfunction stringifyCircular(obj) {\n  const seen = /* @__PURE__ */ new Set();\n  return JSON.stringify(obj, (key, value) => {\n    if (typeof value === \"object\" && value !== null) {\n      if (seen.has(value)) {\n        return \"[Circular]\";\n      }\n      seen.add(value);\n    }\n    return value;\n  });\n}\n__name(stringifyCircular, \"stringifyCircular\");\nvar createAngularInputProperty = /* @__PURE__ */ __name(({\n  propertyName,\n  value,\n  argType\n}) => {\n  let templateValue;\n  switch (typeof value) {\n    case \"string\":\n      templateValue = `'${value}'`;\n      break;\n    case \"object\":\n      templateValue = stringifyCircular(value).replace(/'/g, \"\\u2019\").replace(/\\\\\"/g, \"\\u201D\").replace(/\"([^-\"]+)\":/g, \"$1: \").replace(/\"/g, \"'\").replace(/\\u2019/g, \"\\\\'\").replace(/\\u201D/g, \"\\\\'\").split(\",\").join(\", \");\n      break;\n    default:\n      templateValue = value;\n  }\n  return `[${propertyName}]=\"${templateValue}\"`;\n}, \"createAngularInputProperty\");\nvar computesTemplateSourceFromComponent = /* @__PURE__ */ __name((component, initialProps, argTypes) => {\n  const ngComponentMetadata = getComponentDecoratorMetadata(component);\n  if (!ngComponentMetadata) {\n    return null;\n  }\n  if (!ngComponentMetadata.selector) {\n    return `<ng-container *ngComponentOutlet=\"${component.name}\"></ng-container>`;\n  }\n  const ngComponentInputsOutputs = getComponentInputsOutputs(component);\n  const { inputs: initialInputs, outputs: initialOutputs } = separateInputsOutputsAttributes(\n    ngComponentInputsOutputs,\n    initialProps\n  );\n  const templateInputs = initialInputs.length > 0 ? ` ${initialInputs.map(\n    (propertyName) => createAngularInputProperty({\n      propertyName,\n      value: initialProps[propertyName],\n      argType: argTypes?.[propertyName]\n    })\n  ).join(\" \")}` : \"\";\n  const templateOutputs = initialOutputs.length > 0 ? ` ${initialOutputs.map((i) => `(${i})=\"${formatPropInTemplate(i)}($event)\"`).join(\" \")}` : \"\";\n  return buildTemplate(ngComponentMetadata.selector, \"\", templateInputs, templateOutputs);\n}, \"computesTemplateSourceFromComponent\");\nvar buildTemplate = /* @__PURE__ */ __name((selector, innerTemplate, inputs, outputs) => {\n  const voidElements = [\n    \"area\",\n    \"base\",\n    \"br\",\n    \"col\",\n    \"command\",\n    \"embed\",\n    \"hr\",\n    \"img\",\n    \"input\",\n    \"keygen\",\n    \"link\",\n    \"meta\",\n    \"param\",\n    \"source\",\n    \"track\",\n    \"wbr\"\n  ];\n  const firstSelector = selector.split(\",\")[0];\n  const templateReplacers = [\n    [/(^.*?)(?=[,])/, \"$1\"],\n    [/(^\\..+)/, \"div$1\"],\n    [/(^\\[.+?])/, \"div$1\"],\n    [/([\\w[\\]]+)(\\s*,[\\w\\s-[\\],]+)+/, `$1`],\n    [/#([\\w-]+)/, ` id=\"$1\"`],\n    [/((\\.[\\w-]+)+)/, (_, c) => ` class=\"${c.split`.`.join` `.trim()}\"`],\n    [/(\\[.+?])/g, (_, a) => ` ${a.slice(1, -1)}`],\n    [\n      /([\\S]+)(.*)/,\n      (template, elementSelector) => {\n        return voidElements.some((element) => elementSelector === element) ? template.replace(/([\\S]+)(.*)/, `<$1$2${inputs}${outputs} />`) : template.replace(/([\\S]+)(.*)/, `<$1$2${inputs}${outputs}>${innerTemplate}</$1>`);\n      }\n    ]\n  ];\n  return templateReplacers.reduce(\n    (prevSelector, [searchValue, replacer]) => prevSelector.replace(searchValue, replacer),\n    firstSelector\n  );\n}, \"buildTemplate\");\n\n// src/client/angular-beta/StorybookWrapperComponent.ts\nimport {\n  ChangeDetectorRef,\n  Component as Component3,\n  Inject,\n  NgModule as NgModule2,\n  ViewChild,\n  ViewContainerRef\n} from \"@angular/core\";\nimport { map, skip } from \"rxjs/operators\";\n\n// src/client/angular-beta/StorybookProvider.ts\nimport { InjectionToken, NgZone } from \"@angular/core\";\nimport { Observable } from \"rxjs\";\nvar STORY_PROPS = new InjectionToken(\"STORY_PROPS\");\nvar storyPropsProvider = /* @__PURE__ */ __name((storyProps$) => ({\n  provide: STORY_PROPS,\n  useFactory: storyDataFactory(storyProps$.asObservable()),\n  deps: [NgZone]\n}), \"storyPropsProvider\");\nfunction storyDataFactory(data) {\n  return (ngZone) => new Observable((subscriber) => {\n    const sub = data.subscribe(\n      (v) => {\n        ngZone.run(() => subscriber.next(v));\n      },\n      (err) => {\n        ngZone.run(() => subscriber.error(err));\n      },\n      () => {\n        ngZone.run(() => subscriber.complete());\n      }\n    );\n    return () => {\n      sub.unsubscribe();\n    };\n  });\n}\n__name(storyDataFactory, \"storyDataFactory\");\n\n// src/client/angular-beta/utils/PropertyExtractor.ts\nimport { CommonModule } from \"@angular/common\";\nimport {\n  Component as Component2,\n  Directive as Directive2,\n  Injectable,\n  InjectionToken as InjectionToken2,\n  Input as Input2,\n  Output as Output2,\n  Pipe as Pipe2,\n  \\u0275ReflectionCapabilities as ReflectionCapabilities3,\n  VERSION\n} from \"@angular/core\";\nimport { BrowserModule } from \"@angular/platform-browser\";\nimport { dedent } from \"ts-dedent\";\n\n// src/client/angular-beta/utils/NgModulesAnalyzer.ts\nimport { NgModule, \\u0275ReflectionCapabilities as ReflectionCapabilities2 } from \"@angular/core\";\nvar reflectionCapabilities2 = new ReflectionCapabilities2();\nvar isComponentAlreadyDeclared = /* @__PURE__ */ __name((componentToFind, moduleDeclarations, moduleImports) => {\n  if (moduleDeclarations && moduleDeclarations.flat().some((declaration) => declaration === componentToFind)) {\n    return true;\n  }\n  if (!moduleImports) {\n    return false;\n  }\n  return moduleImports.flat().some((importItem) => {\n    const extractedNgModuleMetadata = extractNgModuleMetadata(importItem);\n    if (!extractedNgModuleMetadata) {\n      return false;\n    }\n    return isComponentAlreadyDeclared(\n      componentToFind,\n      extractedNgModuleMetadata.declarations,\n      extractedNgModuleMetadata.imports\n    );\n  });\n}, \"isComponentAlreadyDeclared\");\nvar extractNgModuleMetadata = /* @__PURE__ */ __name((importItem) => {\n  const target = importItem && importItem.ngModule ? importItem.ngModule : importItem;\n  const decorators = reflectionCapabilities2.annotations(target);\n  if (!decorators || decorators.length === 0) {\n    return null;\n  }\n  const ngModuleDecorator = decorators.find(\n    (decorator) => decorator instanceof NgModule\n  );\n  if (!ngModuleDecorator) {\n    return null;\n  }\n  return ngModuleDecorator;\n}, \"extractNgModuleMetadata\");\n\n// src/client/angular-beta/utils/PropertyExtractor.ts\nvar reflectionCapabilities3 = new ReflectionCapabilities3();\nvar REMOVED_MODULES = new InjectionToken2(\"REMOVED_MODULES\");\nvar uniqueArray = /* @__PURE__ */ __name((arr) => {\n  return arr.flat(Number.MAX_VALUE).filter(Boolean).filter((value, index, self) => self.indexOf(value) === index);\n}, \"uniqueArray\");\nvar _PropertyExtractor = class _PropertyExtractor {\n  constructor(metadata, component) {\n    this.metadata = metadata;\n    this.component = component;\n    this.declarations = [];\n    /**\n     * Analyze NgModule Metadata\n     *\n     * - Removes Restricted Imports\n     * - Extracts providers from ModuleWithProviders\n     * - Returns a new NgModuleMetadata object\n     */\n    this.analyzeMetadata = /* @__PURE__ */ __name(async (metadata) => {\n      const declarations = [...metadata?.declarations || []];\n      const providers = [...metadata?.providers || []];\n      const applicationProviders = [];\n      const imports = await Promise.all(\n        [...metadata?.imports || []].map(async (imported) => {\n          const [isRestricted, restrictedProviders] = await _PropertyExtractor.analyzeRestricted(imported);\n          if (isRestricted) {\n            applicationProviders.unshift(restrictedProviders || []);\n            return null;\n          }\n          return imported;\n        })\n      ).then((results) => results.filter(Boolean));\n      return { ...metadata, imports, providers, applicationProviders, declarations };\n    }, \"analyzeMetadata\");\n  }\n  // With the new way of mounting standalone components to the DOM via bootstrapApplication API,\n  // we should now pass ModuleWithProviders to the providers array of the bootstrapApplication function.\n  static warnImportsModuleWithProviders(propertyExtractor) {\n    const hasModuleWithProvidersImport = propertyExtractor.imports.some(\n      (importedModule) => \"ngModule\" in importedModule\n    );\n    if (hasModuleWithProvidersImport) {\n      console.warn(\n        dedent(\n          `\n          Storybook Warning: \n          moduleMetadata property 'imports' contains one or more ModuleWithProviders, likely the result of a 'Module.forRoot()'-style call.\n          In Storybook 7.0 we use Angular's new 'bootstrapApplication' API to mount the component to the DOM, which accepts a list of providers to set up application-wide providers.\n          Use the 'applicationConfig' decorator from '@storybook/angular' to pass your ModuleWithProviders to the 'providers' property in combination with the importProvidersFrom helper function from '@angular/core' to extract all the necessary providers.\n          Visit https://angular.io/guide/standalone-components#configuring-dependency-injection for more information\n          `\n        )\n      );\n    }\n  }\n  async init() {\n    const analyzed = await this.analyzeMetadata(this.metadata);\n    this.imports = uniqueArray([CommonModule, analyzed.imports]);\n    this.providers = uniqueArray(analyzed.providers);\n    this.applicationProviders = uniqueArray(analyzed.applicationProviders);\n    this.declarations = uniqueArray(analyzed.declarations);\n    if (this.component) {\n      const { isDeclarable, isStandalone } = _PropertyExtractor.analyzeDecorators(this.component);\n      const isDeclared = isComponentAlreadyDeclared(\n        this.component,\n        analyzed.declarations,\n        this.imports\n      );\n      if (isStandalone) {\n        this.imports.push(this.component);\n      } else if (isDeclarable && !isDeclared) {\n        this.declarations.push(this.component);\n      }\n    }\n  }\n};\n__name(_PropertyExtractor, \"PropertyExtractor\");\n_PropertyExtractor.analyzeRestricted = /* @__PURE__ */ __name(async (ngModule) => {\n  if (ngModule === BrowserModule) {\n    console.warn(\n      dedent`\n          Storybook Warning:\n          You have imported the \"BrowserModule\", which is not necessary anymore. \n          In Storybook v7.0 we are using Angular's new bootstrapApplication API to mount an Angular application to the DOM.\n          Note that the BrowserModule providers are automatically included when starting an application with bootstrapApplication()\n          Please remove the \"BrowserModule\" from the list of imports in your moduleMetadata definition to remove this warning.\n        `\n    );\n    return [true];\n  }\n  try {\n    const animations = await import(\"@angular/platform-browser/animations\");\n    if (ngModule === animations.BrowserAnimationsModule) {\n      console.warn(\n        dedent`\n            Storybook Warning:\n            You have added the \"BrowserAnimationsModule\" to the list of \"imports\" in your moduleMetadata definition of your Story.\n            In Storybook 7.0 we use Angular's new 'bootstrapApplication' API to mount the component to the DOM, which accepts a list of providers to set up application-wide providers.\n            Use the 'applicationConfig' decorator from '@storybook/angular' and add the \"provideAnimations\" function to the list of \"providers\".\n            If your Angular version does not support \"provide-like\" functions, use the helper function importProvidersFrom instead to set up animations. For this case, please add \"importProvidersFrom(BrowserAnimationsModule)\" to the list of providers of your applicationConfig definition.\n            Please visit https://angular.io/guide/standalone-components#configuring-dependency-injection for more information.\n          `\n      );\n      return [true, animations.provideAnimations()];\n    }\n    if (ngModule === animations.NoopAnimationsModule) {\n      console.warn(\n        dedent`\n            Storybook Warning:\n            You have added the \"NoopAnimationsModule\" to the list of \"imports\" in your moduleMetadata definition of your Story.\n            In Storybook v7.0 we are using Angular's new bootstrapApplication API to mount an Angular application to the DOM, which accepts a list of providers to set up application-wide providers.\n            Use the 'applicationConfig' decorator from '@storybook/angular' and add the \"provideNoopAnimations\" function to the list of \"providers\".\n            If your Angular version does not support \"provide-like\" functions, use the helper function importProvidersFrom instead to set up noop animations and to extract all necessary providers from NoopAnimationsModule. For this case, please add \"importProvidersFrom(NoopAnimationsModule)\" to the list of providers of your applicationConfig definition.\n            Please visit https://angular.io/guide/standalone-components#configuring-dependency-injection for more information.\n          `\n      );\n      return [true, animations.provideNoopAnimations()];\n    }\n  } catch (e) {\n    return [false];\n  }\n  return [false];\n}, \"analyzeRestricted\");\n_PropertyExtractor.analyzeDecorators = /* @__PURE__ */ __name((component) => {\n  const decorators = reflectionCapabilities3.annotations(component);\n  const isComponent2 = decorators.some((d) => _PropertyExtractor.isDecoratorInstanceOf(d, \"Component\"));\n  const isDirective = decorators.some((d) => _PropertyExtractor.isDecoratorInstanceOf(d, \"Directive\"));\n  const isPipe = decorators.some((d) => _PropertyExtractor.isDecoratorInstanceOf(d, \"Pipe\"));\n  const isDeclarable = isComponent2 || isDirective || isPipe;\n  let isStandalone = (isComponent2 || isDirective) && [...decorators].reverse().find(\n    (d) => _PropertyExtractor.isDecoratorInstanceOf(d, \"Component\") || _PropertyExtractor.isDecoratorInstanceOf(d, \"Directive\")\n  )?.standalone;\n  if (isStandalone === void 0) {\n    isStandalone = !!(VERSION.major && Number(VERSION.major) >= 19);\n  }\n  return { isDeclarable, isStandalone };\n}, \"analyzeDecorators\");\n_PropertyExtractor.isDecoratorInstanceOf = /* @__PURE__ */ __name((decorator, name) => {\n  let factory;\n  switch (name) {\n    case \"Component\":\n      factory = Component2;\n      break;\n    case \"Directive\":\n      factory = Directive2;\n      break;\n    case \"Pipe\":\n      factory = Pipe2;\n      break;\n    case \"Injectable\":\n      factory = Injectable;\n      break;\n    case \"Input\":\n      factory = Input2;\n      break;\n    case \"Output\":\n      factory = Output2;\n      break;\n    default:\n      throw new Error(`Unknown decorator type: ${name}`);\n  }\n  return decorator instanceof factory || decorator.ngMetadataName === name;\n}, \"isDecoratorInstanceOf\");\nvar PropertyExtractor = _PropertyExtractor;\n\n// src/client/angular-beta/StorybookWrapperComponent.ts\nvar getNonInputsOutputsProps = /* @__PURE__ */ __name((ngComponentInputsOutputs, props = {}) => {\n  const inputs = ngComponentInputsOutputs.inputs.filter((i) => i.templateName in props).map((i) => i.templateName);\n  const outputs = ngComponentInputsOutputs.outputs.filter((o) => o.templateName in props).map((o) => o.templateName);\n  return Object.keys(props).filter((k) => ![...inputs, ...outputs].includes(k));\n}, \"getNonInputsOutputsProps\");\nvar createStorybookWrapperComponent = /* @__PURE__ */ __name(({\n  selector,\n  template,\n  storyComponent,\n  styles,\n  moduleMetadata,\n  initialProps,\n  analyzedMetadata\n}) => {\n  const viewChildSelector = storyComponent ?? \"__storybook-noop\";\n  const { imports, declarations, providers } = analyzedMetadata;\n  let StorybookComponentModule = class {\n  };\n  __name(StorybookComponentModule, \"StorybookComponentModule\");\n  StorybookComponentModule = __decorateClass([\n    NgModule2({\n      declarations,\n      imports,\n      exports: [...declarations, ...imports]\n    })\n  ], StorybookComponentModule);\n  PropertyExtractor.warnImportsModuleWithProviders(analyzedMetadata);\n  let StorybookWrapperComponent = class {\n    constructor(storyProps$, changeDetectorRef) {\n      this.storyProps$ = storyProps$;\n      this.changeDetectorRef = changeDetectorRef;\n      // Used in case of a component without selector\n      this.storyComponent = storyComponent ?? \"\";\n    }\n    ngOnInit() {\n      this.storyWrapperPropsSubscription = this.storyProps$.subscribe((storyProps = {}) => {\n        Object.assign(this, storyProps);\n        this.changeDetectorRef.detectChanges();\n        this.changeDetectorRef.markForCheck();\n      });\n    }\n    ngAfterViewInit() {\n      if (this.storyComponentElementRef) {\n        const ngComponentInputsOutputs = getComponentInputsOutputs(storyComponent);\n        const initialOtherProps = getNonInputsOutputsProps(ngComponentInputsOutputs, initialProps);\n        initialOtherProps.forEach((p) => {\n          this.storyComponentElementRef[p] = initialProps[p];\n        });\n        this.storyComponentViewContainerRef.injector.get(ChangeDetectorRef).markForCheck();\n        this.changeDetectorRef.detectChanges();\n        this.storyComponentPropsSubscription = this.storyProps$.pipe(\n          skip(1),\n          map((props) => {\n            const propsKeyToKeep = getNonInputsOutputsProps(ngComponentInputsOutputs, props);\n            return propsKeyToKeep.reduce((acc, p) => ({ ...acc, [p]: props[p] }), {});\n          })\n        ).subscribe((props) => {\n          Object.assign(this.storyComponentElementRef, props);\n          this.storyComponentViewContainerRef.injector.get(ChangeDetectorRef).markForCheck();\n          this.changeDetectorRef.detectChanges();\n        });\n      }\n    }\n    ngOnDestroy() {\n      if (this.storyComponentPropsSubscription != null) {\n        this.storyComponentPropsSubscription.unsubscribe();\n      }\n      if (this.storyWrapperPropsSubscription != null) {\n        this.storyWrapperPropsSubscription.unsubscribe();\n      }\n    }\n  };\n  __name(StorybookWrapperComponent, \"StorybookWrapperComponent\");\n  __decorateClass([\n    ViewChild(viewChildSelector, { static: true })\n  ], StorybookWrapperComponent.prototype, \"storyComponentElementRef\", 2);\n  __decorateClass([\n    ViewChild(viewChildSelector, { read: ViewContainerRef, static: true })\n  ], StorybookWrapperComponent.prototype, \"storyComponentViewContainerRef\", 2);\n  StorybookWrapperComponent = __decorateClass([\n    Component3({\n      selector,\n      template,\n      standalone: true,\n      imports: [StorybookComponentModule],\n      providers,\n      styles,\n      schemas: moduleMetadata.schemas\n    }),\n    __decorateParam(0, Inject(STORY_PROPS)),\n    __decorateParam(1, Inject(ChangeDetectorRef))\n  ], StorybookWrapperComponent);\n  return StorybookWrapperComponent;\n}, \"createStorybookWrapperComponent\");\n\n// src/client/angular-beta/StorybookModule.ts\nvar getApplication = /* @__PURE__ */ __name(({\n  storyFnAngular,\n  component,\n  targetSelector,\n  analyzedMetadata\n}) => {\n  const { props, styles, moduleMetadata = {} } = storyFnAngular;\n  let { template } = storyFnAngular;\n  const hasTemplate = !hasNoTemplate(template);\n  if (!hasTemplate && component) {\n    template = computesTemplateFromComponent(component, props, \"\");\n  }\n  return createStorybookWrapperComponent({\n    moduleMetadata,\n    selector: targetSelector,\n    template,\n    storyComponent: component,\n    styles,\n    initialProps: props,\n    analyzedMetadata\n  });\n}, \"getApplication\");\nfunction hasNoTemplate(template) {\n  return template === null || template === void 0;\n}\n__name(hasNoTemplate, \"hasNoTemplate\");\n\n// src/client/angular-beta/utils/BootstrapQueue.ts\nvar queue = [];\nvar isProcessing = false;\nvar resetCompiledComponents = /* @__PURE__ */ __name(async () => {\n  try {\n    const { \\u0275resetCompiledComponents } = await import(\"@angular/core\");\n    \\u0275resetCompiledComponents();\n  } catch (e) {\n  }\n}, \"resetCompiledComponents\");\nvar queueBootstrapping = /* @__PURE__ */ __name((fn) => {\n  return new Promise((resolve, reject) => {\n    queue.push(() => fn().then(resolve).catch(reject));\n    if (!isProcessing) {\n      processQueue();\n    }\n  });\n}, \"queueBootstrapping\");\nvar processQueue = /* @__PURE__ */ __name(async () => {\n  isProcessing = true;\n  while (queue.length > 0) {\n    const bootstrappingFn = queue.shift();\n    if (bootstrappingFn) {\n      await bootstrappingFn();\n      await resetCompiledComponents();\n    }\n  }\n  isProcessing = false;\n}, \"processQueue\");\n\n// src/client/angular-beta/utils/Zoneless.ts\nvar getProvideZonelessChangeDetectionFn = /* @__PURE__ */ __name(async () => {\n  const angularCore = await import(\"@angular/core\");\n  return \"provideExperimentalZonelessChangeDetection\" in angularCore ? angularCore.provideExperimentalZonelessChangeDetection : \"provideZonelessChangeDetection\" in angularCore ? angularCore.provideZonelessChangeDetection : null;\n}, \"getProvideZonelessChangeDetectionFn\");\n\n// src/client/angular-beta/AbstractRenderer.ts\nvar applicationRefs = /* @__PURE__ */ new Map();\nvar STORY_UID_ATTRIBUTE = \"data-sb-story-uid\";\nvar _AbstractRenderer = class _AbstractRenderer {\n  constructor() {\n    this.previousStoryRenderInfo = /* @__PURE__ */ new Map();\n  }\n  /** Wait and destroy the platform */\n  static resetApplications(domNode) {\n    applicationRefs.forEach((appRef, appDOMNode) => {\n      if (!appRef.destroyed && (!domNode || appDOMNode === domNode)) {\n        appRef.destroy();\n      }\n    });\n  }\n  /**\n   * Bootstrap main angular module with main component or send only new `props` with storyProps$\n   *\n   * @param storyFnAngular {StoryFnAngularReturnType}\n   * @param forced {boolean} If :\n   *\n   *   - True render will only use the StoryFn `props' in storyProps observable that will update sotry's\n   *       component/template properties. Improves performance without reloading the whole\n   *       module&component if props changes\n   *   - False fully recharges or initializes angular module & component\n   *\n   * @param component {Component}\n   */\n  async render({\n    storyFnAngular,\n    forced,\n    component,\n    targetDOMNode\n  }) {\n    const targetSelector = this.generateTargetSelectorFromStoryId(targetDOMNode.id);\n    const newStoryProps$ = new BehaviorSubject(storyFnAngular.props);\n    if (!this.fullRendererRequired({\n      targetDOMNode,\n      storyFnAngular,\n      moduleMetadata: {\n        ...storyFnAngular.moduleMetadata\n      },\n      forced\n    })) {\n      this.storyProps$.next(storyFnAngular.props);\n      return;\n    }\n    await this.beforeFullRender(targetDOMNode);\n    if (this.storyProps$) {\n      this.storyProps$.complete();\n    }\n    this.storyProps$ = newStoryProps$;\n    this.initAngularRootElement(targetDOMNode, targetSelector);\n    const analyzedMetadata = new PropertyExtractor(storyFnAngular.moduleMetadata, component);\n    await analyzedMetadata.init();\n    const storyUid = this.generateStoryUIdFromRawStoryUid(\n      targetDOMNode.getAttribute(STORY_UID_ATTRIBUTE)\n    );\n    const componentSelector = storyUid !== null ? `${targetSelector}[${storyUid}]` : targetSelector;\n    if (storyUid !== null) {\n      const element = targetDOMNode.querySelector(targetSelector);\n      element.toggleAttribute(storyUid, true);\n    }\n    const application = getApplication({\n      storyFnAngular,\n      component,\n      targetSelector: componentSelector,\n      analyzedMetadata\n    });\n    const providers = [\n      storyPropsProvider(newStoryProps$),\n      ...analyzedMetadata.applicationProviders,\n      ...storyFnAngular.applicationConfig?.providers ?? []\n    ];\n    if (STORYBOOK_ANGULAR_OPTIONS?.experimentalZoneless) {\n      const provideZonelessChangeDetectionFn = await getProvideZonelessChangeDetectionFn();\n      if (!provideZonelessChangeDetectionFn) {\n        throw new Error(\"Zoneless change detection requires Angular 18 or higher\");\n      } else {\n        providers.unshift(provideZonelessChangeDetectionFn());\n      }\n    }\n    const applicationRef = await queueBootstrapping(() => {\n      return bootstrapApplication(application, {\n        ...storyFnAngular.applicationConfig,\n        providers\n      });\n    });\n    applicationRefs.set(targetDOMNode, applicationRef);\n  }\n  /**\n   * Only ASCII alphanumerics can be used as HTML tag name. https://html.spec.whatwg.org/#elements-2\n   *\n   * Therefore, stories break when non-ASCII alphanumerics are included in target selector.\n   * https://github.com/storybookjs/storybook/issues/15147\n   *\n   * This method returns storyId when it doesn't contain any non-ASCII alphanumerics. Otherwise, it\n   * generates a valid HTML tag name from storyId by removing non-ASCII alphanumerics from storyId,\n   * prefixing \"sb-\", and suffixing \"-component\"\n   *\n   * @memberof AbstractRenderer\n   * @protected\n   */\n  generateTargetSelectorFromStoryId(id) {\n    const invalidHtmlTag = /[^A-Za-z0-9-]/g;\n    const storyIdIsInvalidHtmlTagName = invalidHtmlTag.test(id);\n    return storyIdIsInvalidHtmlTagName ? `sb-${id.replace(invalidHtmlTag, \"\")}-component` : id;\n  }\n  /**\n   * Angular is unable to handle components that have selectors with accented attributes.\n   *\n   * Therefore, stories break when meta's title contains accents.\n   * https://github.com/storybookjs/storybook/issues/29132\n   *\n   * This method filters accents from a given raw id. For example, this method converts\n   * 'Example/Button with an \"Ã©\" accent' into 'Example/Button with an \"e\" accent'.\n   *\n   * @memberof AbstractRenderer\n   * @protected\n   */\n  generateStoryUIdFromRawStoryUid(rawStoryUid) {\n    if (rawStoryUid === null) {\n      return rawStoryUid;\n    }\n    const accentCharacters = /[\\u0300-\\u036f]/g;\n    return rawStoryUid.normalize(\"NFD\").replace(accentCharacters, \"\");\n  }\n  /** Adds DOM element that angular will use as bootstrap component. */\n  initAngularRootElement(targetDOMNode, targetSelector) {\n    targetDOMNode.innerHTML = \"\";\n    targetDOMNode.appendChild(document.createElement(targetSelector));\n  }\n  fullRendererRequired({\n    targetDOMNode,\n    storyFnAngular,\n    moduleMetadata,\n    forced\n  }) {\n    const previousStoryRenderInfo = this.previousStoryRenderInfo.get(targetDOMNode);\n    const currentStoryRender = {\n      storyFnAngular,\n      moduleMetadataSnapshot: stringify(moduleMetadata, { maxDepth: 50 })\n    };\n    this.previousStoryRenderInfo.set(targetDOMNode, currentStoryRender);\n    if (\n      // check `forceRender` of story RenderContext\n      !forced || // if it's the first rendering and storyProps$ is not init\n      !this.storyProps$\n    ) {\n      return true;\n    }\n    const hasChangedTemplate = !!storyFnAngular?.template && previousStoryRenderInfo?.storyFnAngular?.template !== storyFnAngular.template;\n    if (hasChangedTemplate) {\n      return true;\n    }\n    const hasChangedModuleMetadata = currentStoryRender.moduleMetadataSnapshot !== previousStoryRenderInfo?.moduleMetadataSnapshot;\n    return hasChangedModuleMetadata;\n  }\n};\n__name(_AbstractRenderer, \"AbstractRenderer\");\nvar AbstractRenderer = _AbstractRenderer;\n\n// src/client/angular-beta/CanvasRenderer.ts\nvar _CanvasRenderer = class _CanvasRenderer extends AbstractRenderer {\n  async render(options) {\n    await super.render(options);\n  }\n  async beforeFullRender() {\n    _CanvasRenderer.resetApplications();\n  }\n};\n__name(_CanvasRenderer, \"CanvasRenderer\");\nvar CanvasRenderer = _CanvasRenderer;\n\n// src/client/angular-beta/DocsRenderer.ts\nimport { DOCS_RENDERED, STORY_CHANGED } from \"storybook/internal/core-events\";\nimport { addons } from \"storybook/preview-api\";\n\n// src/client/angular-beta/utils/StoryUID.ts\nvar storyCounts = /* @__PURE__ */ new Map();\nvar getNextStoryUID = /* @__PURE__ */ __name((storyId) => {\n  if (!storyCounts.has(storyId)) {\n    storyCounts.set(storyId, -1);\n  }\n  const count = storyCounts.get(storyId) + 1;\n  storyCounts.set(storyId, count);\n  return `${storyId}-${count}`;\n}, \"getNextStoryUID\");\n\n// src/client/angular-beta/DocsRenderer.ts\nvar _DocsRenderer = class _DocsRenderer extends AbstractRenderer {\n  async render(options) {\n    const channel = addons.getChannel();\n    channel.once(STORY_CHANGED, async () => {\n      await _DocsRenderer.resetApplications();\n    });\n    channel.once(DOCS_RENDERED, async () => {\n      await _DocsRenderer.resetApplications();\n    });\n    await super.render({ ...options, forced: false });\n  }\n  async beforeFullRender(domNode) {\n    _DocsRenderer.resetApplications(domNode);\n  }\n  initAngularRootElement(targetDOMNode, targetSelector) {\n    super.initAngularRootElement(targetDOMNode, targetSelector);\n    targetDOMNode.setAttribute(STORY_UID_ATTRIBUTE, getNextStoryUID(targetDOMNode.id));\n  }\n};\n__name(_DocsRenderer, \"DocsRenderer\");\nvar DocsRenderer = _DocsRenderer;\n\n// src/client/angular-beta/RendererFactory.ts\nvar _RendererFactory = class _RendererFactory {\n  constructor() {\n    this.rendererMap = /* @__PURE__ */ new Map();\n  }\n  async getRendererInstance(targetDOMNode) {\n    const targetId = targetDOMNode.id;\n    if (targetDOMNode === null) {\n      return null;\n    }\n    const renderType = getRenderType(targetDOMNode);\n    if (this.lastRenderType && this.lastRenderType !== renderType) {\n      await AbstractRenderer.resetApplications();\n      clearRootHTMLElement(renderType);\n      this.rendererMap.clear();\n    }\n    if (!this.rendererMap.has(targetId)) {\n      this.rendererMap.set(targetId, this.buildRenderer(renderType));\n    }\n    this.lastRenderType = renderType;\n    return this.rendererMap.get(targetId);\n  }\n  buildRenderer(renderType) {\n    if (renderType === \"docs\") {\n      return new DocsRenderer();\n    }\n    return new CanvasRenderer();\n  }\n};\n__name(_RendererFactory, \"RendererFactory\");\nvar RendererFactory = _RendererFactory;\nvar getRenderType = /* @__PURE__ */ __name((targetDOMNode) => {\n  return targetDOMNode.id === \"storybook-root\" ? \"canvas\" : \"docs\";\n}, \"getRenderType\");\nfunction clearRootHTMLElement(renderType) {\n  switch (renderType) {\n    case \"canvas\":\n      global.document.getElementById(\"storybook-docs\").innerHTML = \"\";\n      break;\n    case \"docs\":\n      global.document.getElementById(\"storybook-root\").innerHTML = \"\";\n      break;\n    default:\n      break;\n  }\n}\n__name(clearRootHTMLElement, \"clearRootHTMLElement\");\n\n// src/client/render.ts\nvar rendererFactory = new RendererFactory();\nvar render = /* @__PURE__ */ __name((props) => ({ props }), \"render\");\nasync function renderToCanvas({ storyFn, showMain, forceRemount, storyContext: { component } }, element) {\n  showMain();\n  const renderer = await rendererFactory.getRendererInstance(element);\n  await renderer.render({\n    storyFnAngular: storyFn(),\n    component,\n    forced: !forceRemount,\n    targetDOMNode: element\n  });\n}\n__name(renderToCanvas, \"renderToCanvas\");\n\nexport {\n  __name,\n  isComponent,\n  formatPropInTemplate,\n  computesTemplateFromComponent,\n  computesTemplateSourceFromComponent,\n  render,\n  renderToCanvas,\n  render_exports\n};\n"],"names":[],"ignoreList":[],"sourceRoot":""}