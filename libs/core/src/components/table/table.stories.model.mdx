import { Meta } from '@storybook/addon-docs/blocks'

<Meta title="Components/Table/Developer Guide" />

# Table Developer Guide

This guide explains how to implement the table component with data handling, pagination, and filtering.

## Table of Contents

1. [Data Model Structure](#data-model-structure)
2. [Data Provider Function](#data-provider-function)
3. [Column Configuration](#column-configuration)
4. [Framework Integration](#framework-integration)
5. [Complete Example](#complete-example)

---

## Data Model Structure

### Request Interface

The table sends this request object to your data provider:

```typescript
interface TableRequest {
  page: number              // Current page (1-indexed)
  rows: number              // Rows per page
  sortColumn?: string       // Column key to sort by
  sortDirection?: 'asc' | 'desc'
  searchQuery?: string      // Search term
}
```

### Response Interface

Your data provider must return:

```typescript
interface TableResponse<T> {
  rows: T[]                 // Array of data rows
  total: number             // Total count (for pagination)
}
```

### Row Type Example

Define your data structure:

```typescript
interface DataRow {
  id: number
  title: string
  description: string
  category: string
  status: 'Active' | 'Inactive'
  amount: number
  date: string
}
```

---

## Data Provider Function

The data provider handles fetching, filtering, sorting, and pagination.

### Server-Side Implementation

```typescript
const dataProvider = async (
  request: TableRequest
): Promise<TableResponse<DataRow>> => {
  const response = await fetch('/api/data', {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify(request),
  })
  
  const data = await response.json()
  
  return {
    rows: data.items,
    total: data.totalCount,
  }
}
```

### Client-Side Implementation

```typescript
const allData: DataRow[] = [
  // Your complete dataset
]

const dataProvider = async (
  request: TableRequest
): Promise<TableResponse<DataRow>> => {
  await new Promise(resolve => setTimeout(resolve, 300))
  
  let processedData = [...allData]
  
  // Apply search filter
  if (request.searchQuery) {
    const query = request.searchQuery.toLowerCase()
    processedData = processedData.filter(row =>
      Object.values(row).some(value =>
        String(value).toLowerCase().includes(query)
      )
    )
  }
  
  // Apply sorting
  if (request.sortColumn) {
    processedData.sort((a, b) => {
      const aValue = String(a[request.sortColumn as keyof DataRow])
      const bValue = String(b[request.sortColumn as keyof DataRow])
      
      return request.sortDirection === 'asc'
        ? aValue.localeCompare(bValue)
        : bValue.localeCompare(aValue)
    })
  }
  
  // Apply pagination
  const startIndex = (request.page - 1) * request.rows
  const endIndex = startIndex + request.rows
  const paginatedData = processedData.slice(startIndex, endIndex)
  
  return {
    rows: paginatedData,
    total: processedData.length,
  }
}
```

---

## Column Configuration

### Basic Column

```typescript
const columns: TableColumn[] = [
  {
    key: 'title',          // Property key in your data
    label: 'Title',        // Column header text
    sortable: true,        // Enable sorting
  }
]
```

### Column with Cell Configuration

```typescript
{
  key: 'status',
  label: 'Status',
  sortable: true,
  cell: {
    value: {
      type: 'badge',
      value: (row: DataRow) => row.status,
      variant: (row: DataRow) => 
        row.status === 'Active' ? 'positive' : 'negative',
    }
  }
}
```

### Available Cell Types

#### Badge
```typescript
cell: {
  value: {
    type: 'badge',
    value: (row) => row.status,
    variant: (row) => 'positive' | 'negative' | 'information',
  }
}
```

#### Button
```typescript
cell: {
  value: {
    type: 'button',
    label: 'Edit',
    size: 'small',
    rank: 'secondary',
    onClick: (row) => console.log('Edit', row),
  }
}
```

#### Link
```typescript
cell: {
  value: {
    type: 'link',
    label: 'View',
    href: (row) => `/items/${row.id}`,
  }
}
```

#### Context Menu
```typescript
cell: {
  value: {
    type: 'context-menu',
    items: [
      {
        label: 'Edit',
        onClick: (row) => console.log('Edit', row),
      },
      {
        label: 'Delete',
        onClick: (row) => console.log('Delete', row),
      },
    ]
  }
}
```

#### Formatted Number
```typescript
cell: {
  value: {
    type: 'formatted-number',
    value: (row) => row.amount,
    format: 'decimalsAndThousands',
    locale: 'sv-SE',
  }
}
```

#### Formatted Date
```typescript
cell: {
  value: {
    type: 'formatted-date',
    value: (row) => row.date,
    format: 'dateLong',
    locale: 'sv-SE',
  }
}
```

### Cell Slots

Add content before (lead) or after (trail) the main value:

```typescript
{
  key: 'description',
  label: 'Description',
  cell: {
    trail: {
      type: 'button',
      size: 'xs',
      rank: 'tertiary',
      template: 'copy-icon',
      onClick: (row) => navigator.clipboard.writeText(row.description),
    }
  }
}
```

---

## Framework Integration

### Lit

```typescript
import { html } from 'lit'
import '@sebgroup/green-core/components/table'

const columns = [
  { key: 'title', label: 'Title', sortable: true },
  { key: 'description', label: 'Description', sortable: true },
]

const dataProvider = async (request) => {
  // Your implementation
}

html`
  <gds-table
    .columns=${columns}
    .data=${dataProvider}
    rows="10"
    searchable
  ></gds-table>
`
```

### React

```tsx
import '@sebgroup/green-core/components/table'

function DataTable() {
  const columns = [
    { key: 'title', label: 'Title', sortable: true },
    { key: 'description', label: 'Description', sortable: true },
  ]

  const dataProvider = async (request) => {
    // Your implementation
  }

  return (
    <gds-table
      columns={columns}
      data={dataProvider}
      rows={10}
      searchable
    />
  )
}
```

### Angular

```typescript
import { Component } from '@angular/core'
import '@sebgroup/green-core/components/table'

@Component({
  selector: 'app-data-table',
  template: `
    <gds-table
      [columns]="columns"
      [data]="dataProvider"
      [rows]="10"
      searchable
    ></gds-table>
  `
})
export class DataTableComponent {
  columns = [
    { key: 'title', label: 'Title', sortable: true },
    { key: 'description', label: 'Description', sortable: true },
  ]

  dataProvider = async (request: any) => {
    // Your implementation
  }
}
```

---

## Complete Example

```typescript
interface DataRow {
  id: number
  title: string
  description: string
  category: string
  status: 'Active' | 'Inactive'
  amount: number
  date: string
}

const columns: TableColumn[] = [
  {
    key: 'id',
    label: 'ID',
    sortable: false,
  },
  {
    key: 'title',
    label: 'Title',
    sortable: true,
  },
  {
    key: 'description',
    label: 'Description',
    sortable: true,
    width: '300px',
  },
  {
    key: 'category',
    label: 'Category',
    sortable: true,
  },
  {
    key: 'status',
    label: 'Status',
    sortable: true,
    cell: {
      value: {
        type: 'badge',
        value: (row: DataRow) => row.status,
        variant: (row: DataRow) =>
          row.status === 'Active' ? 'positive' : 'negative',
      }
    }
  },
  {
    key: 'amount',
    label: 'Amount',
    sortable: true,
    justify: 'end',
    cell: {
      value: {
        type: 'formatted-number',
        value: (row: DataRow) => row.amount,
      }
    }
  },
  {
    key: 'date',
    label: 'Date',
    sortable: true,
    cell: {
      value: {
        type: 'formatted-date',
        value: (row: DataRow) => row.date,
        locale: 'sv-SE',
        format: 'dateLong',
      }
    }
  },
]

const actions = {
  label: 'Actions',
  justify: 'end',
  cell: {
    type: 'context-menu',
    items: [
      {
        label: 'Edit',
        onClick: (row: DataRow) => console.log('Edit', row),
      },
      {
        label: 'View Details',
        onClick: (row: DataRow) => console.log('View', row),
      },
      {
        divider: true,
        label: 'Delete',
        onClick: (row: DataRow) => {
          if (confirm(`Delete ${row.title}?`)) {
            console.log('Delete', row)
          }
        },
      },
    ]
  }
}

const dataProvider = async (
  request: TableRequest
): Promise<TableResponse<DataRow>> => {
  const response = await fetch('/api/data', {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify(request),
  })
  
  const data = await response.json()
  
  return {
    rows: data.items,
    total: data.totalCount,
  }
}

// Usage
html`
  <gds-table
    .columns=${columns}
    .actions=${actions}
    .data=${dataProvider}
    rows="10"
    .options=${[5, 10, 25, 50]}
    searchable
    settings
    selectable
    density="comfortable"
  ></gds-table>
`
```

### Selection Handling

```typescript
const table = document.querySelector('gds-table')

// Listen to selection changes
table.addEventListener('gds-table-selection', (e) => {
  console.log('Selected:', e.detail.selectedData)
  console.log('Count:', e.detail.count)
})

// Programmatic selection
table.setSelection([0, 2, 5])
table.selectAll()
table.clearSelection()

// Get current selection
const selection = table.getSelection()
```

### Custom State Slots

```html
  <gds-table .columns=${columns} .data=${dataProvider} searchable>
    <gds-flex slot="error" flex-direction="column" gap="s">
      <gds-text font="heading-s">Unable to load data</gds-text>
      <gds-text font="detail-book-m">
        An error occurred. Please try again.
      </gds-text>
      <gds-button size="small" @click=${retry}>Retry</gds-button>
    </gds-flex>

    <gds-flex slot="empty" flex-direction="column" gap="s">
      <gds-text font="heading-s">No data available</gds-text>
      <gds-text font="detail-book-m">
        There are no records to display.
      </gds-text>
    </gds-flex>

    <gds-flex slot="no-results" flex-direction="column" gap="s">
      <gds-text font="heading-s">No matches found</gds-text>
      <gds-text font="detail-book-m">
        Try different search terms.
      </gds-text>
      <gds-button size="small" @click=${clearSearch}>
        Clear Search
      </gds-button>
    </gds-flex>
  </gds-table>
```

---

## Best Practices

### Performance
- Use server-side pagination for large datasets (>1000 rows)
- Implement debouncing for search queries
- Cache responses when appropriate

### Column Configuration
- Keep column count reasonable (5-10 visible)
- Use `width` for columns with long content
- Enable sorting only on indexed columns
- Use `justify="end"` for numeric columns

### User Experience
- Use `searchable` boolean to enable search for the data.
- Use `settings` to let users customize columns
- Use `selectable` for bulk actions
- Provide clear empty and error states

---

## API Reference

For complete API documentation, see the main Table component documentation.
 