'use client'

import { useCallback, useEffect, useMemo, useState } from 'react'
import { useRouter, useSearchParams } from 'next/navigation'

import { Types } from '@sebgroup/green-core/components/table'
import * as Core from '@sebgroup/green-core/react'

// --- 1. Typed Configuration ---

interface TableConfig {
  density: Types.Density
  variant: 'primary' | 'secondary' | 'tertiary'
  striped: boolean
  plain: boolean
  height: string
  searchable: boolean
  selectable: boolean
  settings: boolean
  responsive: boolean
  rows: number
  options: number[]
  nocache: boolean
}

const DEFAULT_CONFIG: TableConfig = {
  density: 'comfortable',
  variant: 'secondary',
  striped: false,
  plain: false,
  height: '',
  searchable: true,
  selectable: true,
  settings: true,
  responsive: true,
  rows: 10,
  options: [5, 10, 20, 50],
  nocache: false,
}

// --- 2. Mock Data ---

interface MockRow {
  id: number
  name: string
  email: string
  status: 'Active' | 'Inactive'
  amount: number
  date: string
  avatar: string
  [key: string]: any
}

const MOCK_DATA: MockRow[] = Array.from({ length: 100 }, (_, i) => ({
  id: i + 1,
  name: `User ${i + 1}`,
  email: `user.${i + 1}@company.com`,
  status: i % 3 === 0 ? 'Inactive' : 'Active',
  amount: (i + 1) * 1234.5,
  date: new Date(2024, 0, 1 + i).toISOString(),
  avatar: `https://api.dicebear.com/7.x/avataaars/svg?seed=${i}`,
}))

export default function TablePlayground() {
  const router = useRouter()
  const searchParams = useSearchParams()

  const [isInitialized, setIsInitialized] = useState(false)
  const [config, setConfig] = useState<TableConfig>(DEFAULT_CONFIG)
  const [dataLoadKey, setDataLoadKey] = useState('initial')

  // --- 3. Complex Column Management ---

  type CellTemplate =
    | 'text'
    | 'profile'
    | 'status'
    | 'amount'
    | 'email'
    | 'date'

  // We track the template in _template, but the actual logic lives in the `cell` object
  interface EditableColumn extends Omit<Types.Column, 'cell'> {
    _template: CellTemplate
    cell?: Types.Column['cell']
  }

  const [columns, setColumns] = useState<EditableColumn[]>([
    {
      key: 'name',
      label: 'User',
      sortable: true,
      align: 'start',
      _template: 'profile',
      // DEMO: Lead (Image) + Value (Text)
      cell: {
        lead: {
          type: 'image',
          src: (row: MockRow) => row.avatar,
          alt: (row: MockRow) => row.name,
          width: '24px',
          height: '24px',
        } as unknown as Types.Image,
        value: {
          type: 'formatted-account', // Just using text passed through
          value: (row: MockRow) => row.name,
          format: 'seb-account', // dummy format to pass type check, simply returns string
        } as any,
      },
    },
    {
      key: 'email',
      label: 'Email',
      sortable: true,
      _template: 'email',
      // DEMO: Value (Text) + Trail (Button)
      cell: {
        trail: {
          type: 'button',
          rank: 'tertiary',
          size: 'small',
          label: 'Copy',
          onClick: (row: MockRow) => alert(`Copied ${row.email}`),
        } as unknown as Types.Button,
      },
    },
    {
      key: 'status',
      label: 'Status',
      align: 'center',
      _template: 'status',
      // DEMO: Value (Badge)
      cell: {
        value: {
          type: 'badge',
          value: (row: MockRow) => row.status,
          variant: (row: MockRow) =>
            row.status === 'Active' ? 'positive' : 'negative',
        } as unknown as Types.Badge,
      },
    },
    {
      key: 'amount',
      label: 'Amount',
      align: 'end',
      justify: 'end',
      _template: 'amount',
      // DEMO: Value (Number) + Trail (Badge)
      cell: {
        value: {
          type: 'formatted-number',
          value: (row: MockRow) => row.amount,
          format: 'decimalsAndThousands',
        } as unknown as Types.FormattedNumber,
        trail: {
          type: 'badge',
          value: 'SEK',
          variant: 'information',
        } as unknown as Types.Badge,
      },
    },
  ])

  // --- 4. Logic to Apply Templates ---

  const applyTemplate = (
    col: EditableColumn,
    template: CellTemplate,
  ): EditableColumn => {
    const key = col.key
    const newCol = { ...col, _template: template }

    switch (template) {
      case 'text':
        newCol.cell = undefined
        break

      case 'profile':
        newCol.cell = {
          lead: {
            type: 'image',
            src: (row: any) =>
              `https://api.dicebear.com/7.x/avataaars/svg?seed=${row.id}`,
            width: '24px',
            height: '24px',
          } as unknown as Types.Image,
          // If value is undefined, it defaults to row[key] which is what we want for text
        }
        break

      case 'status':
        newCol.cell = {
          value: {
            type: 'badge',
            value: (row: any) => row[key],
            variant: (row: any) => {
              const val = String(row[key])
              return val === 'Active' ? 'positive' : 'negative'
            },
          } as unknown as Types.Badge,
        }
        break

      case 'amount':
        newCol.cell = {
          value: {
            type: 'formatted-number',
            value: (row: any) => row[key],
            format: 'decimalsAndThousands',
          } as unknown as Types.FormattedNumber,
          trail: {
            type: 'badge',
            value: 'SEK',
          } as unknown as Types.Badge,
        }
        break

      case 'email':
        newCol.cell = {
          trail: {
            type: 'button',
            rank: 'tertiary',
            label: 'Copy',
            onClick: () => {},
          } as unknown as Types.Button,
        }
        break

      case 'date':
        newCol.cell = {
          value: {
            type: 'formatted-date',
            value: (row: any) => row[key],
            format: 'dateLong',
            locale: 'sv-SE',
          } as unknown as Types.FormattedDate,
        }
        break
    }
    return newCol
  }

  // --- 5. Initialization & Sync ---

  useEffect(() => {
    const newConfig = { ...DEFAULT_CONFIG }
    const getBool = (key: string) => searchParams.get(key) === 'true'

    if (searchParams.has('searchable'))
      newConfig.searchable = getBool('searchable')
    if (searchParams.has('selectable'))
      newConfig.selectable = getBool('selectable')
    if (searchParams.has('settings')) newConfig.settings = getBool('settings')
    if (searchParams.has('striped')) newConfig.striped = getBool('striped')
    if (searchParams.has('responsive'))
      newConfig.responsive = getBool('responsive')
    if (searchParams.has('plain')) newConfig.plain = getBool('plain')
    if (searchParams.has('nocache')) newConfig.nocache = getBool('nocache')

    if (searchParams.get('density'))
      newConfig.density = searchParams.get('density') as Types.Density
    if (searchParams.get('variant'))
      newConfig.variant = searchParams.get('variant') as any
    if (searchParams.get('height'))
      newConfig.height = searchParams.get('height')!

    if (searchParams.get('rows'))
      newConfig.rows = parseInt(searchParams.get('rows')!)
    if (searchParams.get('options')) {
      try {
        newConfig.options = JSON.parse(searchParams.get('options')!)
      } catch (e) {}
    }

    setConfig(newConfig)
    setIsInitialized(true)
  }, [])

  useEffect(() => {
    if (!isInitialized) return
    const params = new URLSearchParams()

    Object.entries(config).forEach(([key, val]) => {
      params.set(
        key,
        typeof val === 'object' ? JSON.stringify(val) : String(val),
      )
    })

    router.replace(`?${params.toString()}`, { scroll: false })

    // Changing this key forces the data provider to re-run,
    // but React props update immediately regardless.
    setDataLoadKey(`reload-${Date.now()}`)
  }, [config, columns, isInitialized])

  // --- 6. Data Provider ---

  const dataProvider = useCallback(
    async (request: Types.Request): Promise<Types.Response<any>> => {
      let filtered = [...MOCK_DATA]

      if (request.searchQuery) {
        const q = request.searchQuery.toLowerCase()
        filtered = filtered.filter((row) =>
          Object.values(row).some((v) => String(v).toLowerCase().includes(q)),
        )
      }

      if (request.sortColumn) {
        filtered.sort((a, b) => {
          const aVal = a[request.sortColumn as keyof MockRow]
          const bVal = b[request.sortColumn as keyof MockRow]
          if (aVal < bVal) return request.sortDirection === 'asc' ? -1 : 1
          if (aVal > bVal) return request.sortDirection === 'asc' ? 1 : -1
          return 0
        })
      }

      const start = (request.page - 1) * request.rows
      return {
        rows: filtered.slice(start, start + request.rows),
        total: filtered.length,
      }
    },
    [],
  )

  // --- 7. Handlers ---

  const updateConfig = (updates: Partial<TableConfig>) => {
    // Creating a new object reference triggers React re-render
    setConfig((prev) => ({ ...prev, ...updates }))
  }

  const updateColumn = (
    index: number,
    updates: Partial<EditableColumn>,
    templateChange?: CellTemplate,
  ) => {
    setColumns((prev) => {
      const newCols = [...prev]
      let col = { ...newCols[index], ...updates }

      if (templateChange) {
        col = applyTemplate(col, templateChange)
      }

      newCols[index] = col
      return newCols
    })
  }

  const addColumn = () => {
    setColumns((prev) => [
      ...prev,
      {
        key: `col${prev.length}`,
        label: 'New',
        sortable: false,
        _template: 'text',
      },
    ])
  }

  const removeColumn = (idx: number) => {
    setColumns((prev) => prev.filter((_, i) => i !== idx))
  }

  const tableColumns = useMemo(() => {
    return columns.map(({ _template, ...rest }) => rest as Types.Column)
  }, [columns])

  if (!isInitialized) return null

  return (
    <Core.GdsTheme>
      <Core.GdsFlex gap="s" style={{ height: '100vh', padding: '20px' }}>
        {/* --- LEFT: CONFIG --- */}
        <Core.GdsCard style={{ width: '400px', overflowY: 'auto' }}>
          <Core.GdsFlex flex-direction="column" gap="m">
            <Core.GdsText font="heading-s">Configuration</Core.GdsText>

            {/* Pagination */}
            <section>
              <Core.GdsText font="detail-s" weight="bold">
                Pagination
              </Core.GdsText>
              <Core.GdsFlex gap="s" margin="s 0 0 0">
                <Core.GdsInput
                  label="Rows per Page"
                  type="number"
                  value={config.rows.toString()}
                  onInput={(e: any) =>
                    updateConfig({ rows: parseInt(e.target.value) || 10 })
                  }
                />
                <Core.GdsInput
                  label="Options"
                  value={config.options.join(',')}
                  onInput={(e: any) => {
                    const vals = e.target.value
                      .split(',')
                      .map((v: string) => parseInt(v.trim()))
                      .filter((n: number) => !isNaN(n))
                    if (vals.length) updateConfig({ options: vals })
                  }}
                />
              </Core.GdsFlex>
            </section>

            <Core.GdsDivider />

            {/* Toggles */}
            <section>
              <Core.GdsText font="detail-s" weight="bold">
                Features
              </Core.GdsText>
              <Core.GdsFlex flex-direction="column" gap="s" margin="s 0 0 0">
                <Core.GdsCheckbox
                  checked={config.searchable}
                  onInput={(e: any) =>
                    updateConfig({ searchable: e.target.checked })
                  }
                  label="Searchable"
                />
                <Core.GdsCheckbox
                  checked={config.selectable}
                  onInput={(e: any) =>
                    updateConfig({ selectable: e.target.checked })
                  }
                  label="Selectable"
                />
                <Core.GdsCheckbox
                  checked={config.settings}
                  onInput={(e: any) =>
                    updateConfig({ settings: e.target.checked })
                  }
                  label="Column Settings"
                />
                <Core.GdsCheckbox
                  checked={config.striped}
                  onInput={(e: any) =>
                    updateConfig({ striped: e.target.checked })
                  }
                  label="Striped Rows"
                />
                <Core.GdsCheckbox
                  checked={config.plain}
                  onInput={(e: any) =>
                    updateConfig({ plain: e.target.checked })
                  }
                  label="Plain (No Header/Footer)"
                />
                <Core.GdsCheckbox
                  checked={config.nocache}
                  onInput={(e: any) =>
                    updateConfig({ nocache: e.target.checked })
                  }
                  label="Disable Caching"
                />
              </Core.GdsFlex>
            </section>

            <Core.GdsDivider />

            {/* Style */}
            <section>
              <Core.GdsText font="detail-s" weight="bold">
                Appearance
              </Core.GdsText>
              <Core.GdsFlex gap="s" flex-direction="column" margin="s 0 0 0">
                <Core.GdsDropdown
                  label="Density"
                  value={config.density}
                  onChange={(e: any) =>
                    updateConfig({ density: e.detail.value })
                  }
                >
                  <Core.GdsOption value="compact">Compact</Core.GdsOption>
                  <Core.GdsOption value="comfortable">
                    Comfortable
                  </Core.GdsOption>
                  <Core.GdsOption value="spacious">Spacious</Core.GdsOption>
                </Core.GdsDropdown>
                <Core.GdsDropdown
                  label="Variant"
                  value={config.variant}
                  onChange={(e: any) =>
                    updateConfig({ variant: e.detail.value })
                  }
                >
                  <Core.GdsOption value="primary">Primary</Core.GdsOption>
                  <Core.GdsOption value="secondary">Secondary</Core.GdsOption>
                  <Core.GdsOption value="tertiary">Tertiary</Core.GdsOption>
                </Core.GdsDropdown>
                <Core.GdsInput
                  label="Height"
                  placeholder="e.g. 500px"
                  value={config.height}
                  onInput={(e: any) => updateConfig({ height: e.target.value })}
                />
              </Core.GdsFlex>
            </section>

            <Core.GdsDivider />

            {/* Columns */}
            <section>
              <Core.GdsFlex
                justify-content="space-between"
                align-items="center"
                margin="0 0 s 0"
              >
                <Core.GdsText font="detail-s" weight="bold">
                  Columns
                </Core.GdsText>
                <Core.GdsButton
                  size="small"
                  rank="secondary"
                  onClick={addColumn}
                >
                  + Add
                </Core.GdsButton>
              </Core.GdsFlex>

              <Core.GdsFlex flex-direction="column" gap="s">
                {columns.map((col, idx) => (
                  <Core.GdsCard
                    key={idx}
                    variant="tertiary"
                    padding="s"
                    border-radius="s"
                  >
                    <Core.GdsFlex flex-direction="column" gap="s">
                      <Core.GdsFlex gap="s">
                        <Core.GdsInput
                          label="Key"
                          value={col.key}
                          size="small"
                          onInput={(e: any) =>
                            updateColumn(idx, { key: e.target.value })
                          }
                        />
                        <Core.GdsInput
                          label="Label"
                          value={col.label}
                          size="small"
                          onInput={(e: any) =>
                            updateColumn(idx, { label: e.target.value })
                          }
                        />
                      </Core.GdsFlex>

                      <Core.GdsFlex gap="s">
                        <Core.GdsDropdown
                          label="Cell Template"
                          size="small"
                          value={col._template || 'text'}
                          onChange={(e: any) =>
                            updateColumn(idx, {}, e.detail.value)
                          }
                        >
                          <Core.GdsOption value="text">
                            Simple Text
                          </Core.GdsOption>
                          <Core.GdsOption value="profile">
                            User Profile (Lead+Text)
                          </Core.GdsOption>
                          <Core.GdsOption value="amount">
                            Amount (Value+Trail)
                          </Core.GdsOption>
                          <Core.GdsOption value="email">
                            Email (Text+Trail Button)
                          </Core.GdsOption>
                          <Core.GdsOption value="status">
                            Status Badge
                          </Core.GdsOption>
                          <Core.GdsOption value="date">Date</Core.GdsOption>
                        </Core.GdsDropdown>

                        <Core.GdsInput
                          label="Width"
                          placeholder="auto"
                          value={col.width || ''}
                          size="small"
                          onInput={(e: any) =>
                            updateColumn(idx, { width: e.target.value })
                          }
                        />
                      </Core.GdsFlex>

                      <Core.GdsFlex gap="s">
                        <Core.GdsDropdown
                          label="Align"
                          size="small"
                          value={col.align || 'start'}
                          onChange={(e: any) =>
                            updateColumn(idx, { align: e.detail.value })
                          }
                        >
                          <Core.GdsOption value="start">Start</Core.GdsOption>
                          <Core.GdsOption value="center">Center</Core.GdsOption>
                          <Core.GdsOption value="end">End</Core.GdsOption>
                        </Core.GdsDropdown>
                        <Core.GdsDropdown
                          label="Justify"
                          size="small"
                          value={col.justify || 'start'}
                          onChange={(e: any) =>
                            updateColumn(idx, { justify: e.detail.value })
                          }
                        >
                          <Core.GdsOption value="start">Start</Core.GdsOption>
                          <Core.GdsOption value="center">Center</Core.GdsOption>
                          <Core.GdsOption value="space-between">
                            Space Between
                          </Core.GdsOption>
                          <Core.GdsOption value="end">End</Core.GdsOption>
                        </Core.GdsDropdown>
                      </Core.GdsFlex>

                      <Core.GdsFlex
                        justify-content="space-between"
                        align-items="center"
                      >
                        <Core.GdsCheckbox
                          label="Sortable"
                          checked={col.sortable || false}
                          onInput={(e: any) =>
                            updateColumn(idx, { sortable: e.target.checked })
                          }
                        />
                        <Core.GdsButton
                          size="small"
                          rank="tertiary"
                          variant="negative"
                          onClick={() => removeColumn(idx)}
                        >
                          Remove
                        </Core.GdsButton>
                      </Core.GdsFlex>
                    </Core.GdsFlex>
                  </Core.GdsCard>
                ))}
              </Core.GdsFlex>
            </section>
          </Core.GdsFlex>
        </Core.GdsCard>

        {/* --- RIGHT: PREVIEW --- */}
        <Core.GdsFlex
          flex="1"
          flex-direction="column"
          gap="m"
          style={{ overflow: 'hidden' }}
        >
          <Core.GdsCard
            flex="1"
            style={{
              display: 'flex',
              flexDirection: 'column',
              overflow: 'hidden',
            }}
          >
            <Core.GdsText font="heading-s" margin="0 0 m 0">
              Preview
            </Core.GdsText>
            <div style={{ flex: 1, overflow: 'auto' }}>
              <Core.GdsTable
                // Data
                columns={tableColumns}
                data={dataProvider}
                dataLoadKey={dataLoadKey}
                // Config Props (Directly bound to state)
                rows={config.rows}
                options={config.options}
                density={config.density}
                variant={config.variant}
                height={config.height}
                // Booleans
                searchable={config.searchable}
                selectable={config.selectable}
                settings={config.settings}
                striped={config.striped}
                plain={config.plain}
                responsive={config.responsive}
                nocache={config.nocache}
              />
            </div>
          </Core.GdsCard>
        </Core.GdsFlex>
      </Core.GdsFlex>
    </Core.GdsTheme>
  )
}
